//----------------------------------------------------
// code was generated by JCUP V0.13
// Mon Feb 15 11:17:01 GMT+10:30 1999
//----------------------------------------------------

package jaco.join.grammar;

import jaco.join.struct.*;
import jaco.java.struct.*;
import jaco.java.component.*;
import jaco.framework.*;

public final class Parser extends jaco.framework.parser.LRParser {

  /** constructor */
  public Parser() {super();}

  /** production table */
  protected static final short _production_table[][] = {
        {0, 2},     {16, 1},     {1, 1},     {1, 3},     {2, 1}, 
        {2, 3},     {2, 3},     {3, 1},     {3, 7},     {4, 1}, 
        {4, 3},     {4, 3},     {4, 3},     {4, 3},     {4, 3}, 
        {4, 3},     {4, 3},     {4, 3},     {4, 3},     {4, 3}, 
        {4, 3},     {4, 3},     {5, 1},     {5, 2},     {15, 1}, 
        {15, 2},     {15, 2},     {6, 1},     {6, 1},     {6, 3}, 
        {6, 1},     {11, 1},     {7, 1},     {7, 1},     {7, 1}, 
        {7, 1},     {7, 1},     {7, 1},     {7, 1},     {7, 1}, 
        {7, 1},     {8, 2},     {8, 3},     {17, 1},     {17, 3}, 
        {9, 3},     {20, 0},     {20, 1},     {18, 1},     {18, 3}, 
        {10, 3},     {10, 3},     {10, 3},     {10, 3},     {12, 2}, 
        {12, 2},     {12, 2},     {12, 3},     {13, 1},     {13, 2}, 
        {13, 2},     {13, 2},     {14, 2},     {14, 3},     {19, 1}, 
        {19, 1},     {19, 1},     {19, 3},     {19, 3},     {19, 3}
      };

  /** access to production table */
  public short[][] production_table() {return _production_table;}

  /** parse action table */
  protected static short[][] _action_table;

  /** access to parse action table */
  public short[][] action_table() {return _action_table;}

  /** reduce_goto table */
  protected static short[][] _reduce_table;

  /** access to reduce_goto table */
  public short[][] reduce_table() {return _reduce_table;}

  static {
    try {
      java.io.ObjectInputStream p = new java.io.ObjectInputStream(find_tables("jaco.join.grammar.Parser"));
      _action_table = (short[][])p.readObject();
      _reduce_table = (short[][])p.readObject();
    }
    catch (Exception e) {
      throw new RuntimeException("unable to load parser tables: " + e);
    }
  }
  /** instance of action encapsulation class */
  protected ParserActions action_obj;

  /** action encapsulation object initializer */
  protected void init_actions()
  {
      actObj = (action_obj = new ParserActions(this, stack));
  }

  /** start state */
  public final int start_state() {return 0;}
  /** start production */
  public final int start_production() { return 0; }

  /** EOF Symbol index */
  public final int EOF_sym() { return 0; }

  /** error Symbol index */
  public final int error_sym() { return 1; }


  /** user initialization */
  public final void user_init() throws java.lang.Exception
  {

    action_obj.lexer = lexer;
    action_obj.make = lexer.jmake;
    action_obj.report = report;
    action_obj.varnum = 0;

  }

  /** scan to get the next Symbol */
  public final jaco.framework.parser.Symbol scan()
    throws java.lang.Exception
  {

    Object  obj = null;
    switch (lexer.token)
    {
        case Symbols.IDENTIFIER:
            obj = lexer.name;
            break;
                
        case Symbols.CHARLIT:
            obj = mkConst.IntConst((int)lexer.intVal, TypeConst.CHAR);
            break;
            
        case Symbols.INTLIT:
            obj = mkConst.IntConst((int)lexer.intVal);
            break;
            
        case Symbols.LONGLIT:
            obj = mkConst.LongConst(lexer.intVal);
            break;
            
        case Symbols.FLOATLIT:
            obj = mkConst.FloatConst((float)lexer.floatVal);
            break;
            
        case Symbols.DOUBLELIT:
            obj = mkConst.DoubleConst(lexer.floatVal);
            break;
            
        case Symbols.STRLIT:
            obj = mkConst.StringConst(lexer.name);
            break;
        
        default:
            obj = null;
    }
    jaco.framework.parser.Symbol    sym =
        new jaco.framework.parser.Symbol(lexer.token,
                                    lexer.pos,
                                    Position.encode(lexer.cline, lexer.ccol),
                                    obj);
    lexer.nextToken();
    return sym;

  }


/* other components of the jaco compiler
 */
    Scanner             lexer;
    ErrorHandler        report;
    Constant.Factory    mkConst;
    
    
    public Parser(Scanner lexer)
    {
        this.lexer = lexer;
        this.report = lexer.report;
        this.mkConst = lexer.constants.make;
    }
    
    public void report_error(String message, Object info)
    {
        if ((info instanceof jaco.framework.parser.Symbol) &&
            (((jaco.framework.parser.Symbol)info).sym > 0))
        {
            if (((jaco.framework.parser.Symbol)info).left != -1)
                report.error(((jaco.framework.parser.Symbol)info).left,
                        message + " (" +
                        ((jaco.framework.parser.Symbol)info).sym + ")");
            else
                report.error(Position.NOPOS, message);
        }
        else
            report.error(Position.NOPOS, message);
    }
    
    public void report_fatal_error(String message, Object info) throws Exception
    {
        done_parsing();
        report_error("fatal error: " + message, info);
        throw new Exception();
    }
    
    public void syntax_error(jaco.framework.parser.Symbol cur_token)
    {
        report_error("syntax error", cur_token);
    }
    
    protected int error_sync_size()
    {
        return 2;
    }

};

/** Cup generated class to encapsulate user supplied action code.*/
class ParserActions implements jaco.framework.parser.ActionInterface {
  protected jaco.framework.parser.LRParser   jcup$parser;
  protected jaco.framework.parser.ParseStack jcup$stack;


    JTree.Factory   make;
    Scanner         lexer;
    ErrorHandler    report;
    int             varnum;
    
    private static JTree at(int pos, JTree tree) {
        tree.pos = pos;
        return tree;
    }
    
    private static JTree[] append(JTree[] ts, JTree t) {
        if (t == null)
            return ts;
        else if (ts == null)
            return new JTree[]{t};
        JTree[] newtrees = new JTree[ts.length + 1];
        System.arraycopy(ts, 0, newtrees, 0, ts.length);
        newtrees[ts.length] = t;
        return newtrees;
    }
    
    private JTree anonVar(int pos) {
        return at(pos, make.Ident(Name.fromString("x$" + varnum++)));
    }


  /** Constructor */
  ParserActions(
    jaco.framework.parser.LRParser   parser,
    jaco.framework.parser.ParseStack stack)
  {
      jcup$parser = parser;
      jcup$stack = stack;
  }

  /** Method with the actual generated action code. */
  public final jaco.framework.parser.Symbol doAction(
    int jcup$act_num,
    int jcup$top)
    throws java.lang.Exception
    {
      /* the parse stack */
      jaco.framework.parser.Symbol[] $stack = jcup$stack.stack;

      /* select the action based on the action number */
      switch (jcup$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // NamesOrTupels ::= NamesOrTupels COMMA SUB 
            {
        JTree[] RESULT = null;
        JTree[] is = (JTree[])$stack[jcup$top-2].value;
        Object t = (Object)$stack[jcup$top].value;
        int tleft = $stack[jcup$top].left;
         RESULT = append(is, anonVar(tleft));
              return jcup$stack.reuse(19/*NamesOrTupels*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // NamesOrTupels ::= NamesOrTupels COMMA LhsTupel 
            {
        JTree[] RESULT = null;
        JTree[] is = (JTree[])$stack[jcup$top-2].value;
        JTree t = (JTree)$stack[jcup$top].value;
         RESULT = append(is, t);
              return jcup$stack.reuse(19/*NamesOrTupels*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // NamesOrTupels ::= NamesOrTupels COMMA Name 
            {
        JTree[] RESULT = null;
        JTree[] is = (JTree[])$stack[jcup$top-2].value;
        JTree t = (JTree)$stack[jcup$top].value;
         RESULT = append(is, t);
              return jcup$stack.reuse(19/*NamesOrTupels*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // NamesOrTupels ::= SUB 
            {
        JTree[] RESULT = null;
        Object t = (Object)$stack[jcup$top].value;
        int tleft = $stack[jcup$top].left;
         RESULT = new JTree[]{anonVar(tleft)};
              return jcup$stack.reuse(19/*NamesOrTupels*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // NamesOrTupels ::= LhsTupel 
            {
        JTree[] RESULT = null;
        JTree t = (JTree)$stack[jcup$top].value;
         RESULT = new JTree[]{t};
              return jcup$stack.reuse(19/*NamesOrTupels*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // NamesOrTupels ::= Name 
            {
        JTree[] RESULT = null;
        JTree t = (JTree)$stack[jcup$top].value;
         RESULT = new JTree[]{t};
              return jcup$stack.reuse(19/*NamesOrTupels*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // LhsTupel ::= LPAREN NamesOrTupels RPAREN 
            {
        JTree RESULT = null;
        Object p = (Object)$stack[jcup$top-2].value;
        JTree[] is = (JTree[])$stack[jcup$top-1].value;
        int pleft = $stack[jcup$top-2].left;
         RESULT = (is.length == 1) ?
                                is[0] : at(pleft, make.Tupel(is));
              return jcup$stack.reuse(14/*LhsTupel*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // LhsTupel ::= LPAREN RPAREN 
            {
        JTree RESULT = null;
        Object p = (Object)$stack[jcup$top-1].value;
        int pleft = $stack[jcup$top-1].left;
         RESULT = at(pleft, make.Tupel(new JTree[0]));
              return jcup$stack.reuse(14/*LhsTupel*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // SimpleLhs ::= Name LhsTupel 
            {
        JTree RESULT = null;
        JTree f = (JTree)$stack[jcup$top-1].value;
        JTree a = (JTree)$stack[jcup$top].value;
        int fleft = $stack[jcup$top-1].left;
         RESULT = at(fleft, make.Apply(f, a));
              return jcup$stack.reuse(13/*SimpleLhs*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // SimpleLhs ::= Name SUB 
            {
        JTree RESULT = null;
        JTree f = (JTree)$stack[jcup$top-1].value;
        int fleft = $stack[jcup$top-1].left;
         RESULT = at(fleft, make.Apply(f, anonVar(fleft)));
              return jcup$stack.reuse(13/*SimpleLhs*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // SimpleLhs ::= Name Name 
            {
        JTree RESULT = null;
        JTree f = (JTree)$stack[jcup$top-1].value;
        JTree a = (JTree)$stack[jcup$top].value;
        int fleft = $stack[jcup$top-1].left;
         RESULT = at(fleft, make.Apply(f, a));
              return jcup$stack.reuse(13/*SimpleLhs*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // SimpleLhs ::= Name 
            {
        JTree RESULT = null;
        JTree t = (JTree)$stack[jcup$top].value;
         RESULT = t;
              return jcup$stack.reuse(13/*SimpleLhs*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // LeftHandSide ::= LeftHandSide AMPERSAND SimpleLhs 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Join(l, r));
              return jcup$stack.reuse(12/*LeftHandSide*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // LeftHandSide ::= Name LhsTupel 
            {
        JTree RESULT = null;
        JTree f = (JTree)$stack[jcup$top-1].value;
        JTree a = (JTree)$stack[jcup$top].value;
        int fleft = $stack[jcup$top-1].left;
         RESULT = at(fleft, make.Apply(f, a));
              return jcup$stack.reuse(12/*LeftHandSide*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // LeftHandSide ::= Name SUB 
            {
        JTree RESULT = null;
        JTree f = (JTree)$stack[jcup$top-1].value;
        int fleft = $stack[jcup$top-1].left;
         RESULT = at(fleft, make.Apply(f, anonVar(fleft)));
              return jcup$stack.reuse(12/*LeftHandSide*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // LeftHandSide ::= Name Name 
            {
        JTree RESULT = null;
        JTree f = (JTree)$stack[jcup$top-1].value;
        JTree a = (JTree)$stack[jcup$top].value;
        int fleft = $stack[jcup$top-1].left;
         RESULT = at(fleft, make.Apply(f, a));
              return jcup$stack.reuse(12/*LeftHandSide*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // Definition ::= Name EQUALS TopLevelDef 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Decl(l, r));
              return jcup$stack.reuse(10/*Definition*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // Definition ::= LhsTupel EQUALS Term 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Decl(l, r));
              return jcup$stack.reuse(10/*Definition*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // Definition ::= Name EQUALS Term 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Decl(l, r));
              return jcup$stack.reuse(10/*Definition*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // Definition ::= LeftHandSide EQUALS Term 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Decl(l, r));
              return jcup$stack.reuse(10/*Definition*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // Definitions ::= Definitions COMMA Definition 
            {
        JTree[] RESULT = null;
        JTree[] ds = (JTree[])$stack[jcup$top-2].value;
        JTree d = (JTree)$stack[jcup$top].value;
         RESULT = append(ds, d);
              return jcup$stack.reuse(18/*Definitions*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // Definitions ::= Definition 
            {
        JTree[] RESULT = null;
        JTree d = (JTree)$stack[jcup$top].value;
         RESULT = new JTree[]{d};
              return jcup$stack.reuse(18/*Definitions*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // DefinitionsOpt ::= Definitions 
            {
        JTree[] RESULT = null;
        JTree[] ds = (JTree[])$stack[jcup$top].value;
         RESULT = ds;
              return jcup$stack.reuse(20/*DefinitionsOpt*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // DefinitionsOpt ::= 
            {
        JTree[] RESULT = null;
        RESULT = new JTree[0];
              return new jaco.framework.parser.Symbol(20/*DefinitionsOpt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // TopLevelDef ::= LBRACE DefinitionsOpt RBRACE 
            {
        JTree RESULT = null;
        Object l = (Object)$stack[jcup$top-2].value;
        JTree[] d = (JTree[])$stack[jcup$top-1].value;
        int lleft = $stack[jcup$top-2].left;
         RESULT = at(lleft, make.Decls(d));
              return jcup$stack.reuse(9/*TopLevelDef*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // Terms ::= Terms COMMA Term 
            {
        JTree[] RESULT = null;
        JTree[] ts = (JTree[])$stack[jcup$top-2].value;
        JTree t = (JTree)$stack[jcup$top].value;
         RESULT = append(ts, t);
              return jcup$stack.reuse(17/*Terms*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // Terms ::= Term 
            {
        JTree[] RESULT = null;
        JTree t = (JTree)$stack[jcup$top].value;
         RESULT = new JTree[]{t};
              return jcup$stack.reuse(17/*Terms*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // TermTupel ::= LPAREN Terms RPAREN 
            {
        JTree RESULT = null;
        Object p = (Object)$stack[jcup$top-2].value;
        JTree[] ts = (JTree[])$stack[jcup$top-1].value;
        int pleft = $stack[jcup$top-2].left;
         RESULT = (ts.length == 1) ?
                        ts[0] : at(pleft, make.Tupel(ts));
              return jcup$stack.reuse(8/*TermTupel*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // TermTupel ::= LPAREN RPAREN 
            {
        JTree RESULT = null;
        Object p = (Object)$stack[jcup$top-1].value;
        int pleft = $stack[jcup$top-1].left;
         RESULT = at(pleft, make.Tupel(new JTree[0]));
              return jcup$stack.reuse(8/*TermTupel*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // Literal ::= ERROR 
            {
        JTree RESULT = null;
        Object l = (Object)$stack[jcup$top].value;
        int lleft = $stack[jcup$top].left;
         RESULT = at(lleft, make.SpecialLiteral(JoinConst.ERROR));
              return jcup$stack.reuse(7/*Literal*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // Literal ::= FALSE 
            {
        JTree RESULT = null;
        Object l = (Object)$stack[jcup$top].value;
        int lleft = $stack[jcup$top].left;
         RESULT = at(lleft, make.SpecialLiteral(JoinConst.FALSE));
              return jcup$stack.reuse(7/*Literal*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // Literal ::= TRUE 
            {
        JTree RESULT = null;
        Object l = (Object)$stack[jcup$top].value;
        int lleft = $stack[jcup$top].left;
         RESULT = at(lleft, make.SpecialLiteral(JoinConst.TRUE));
              return jcup$stack.reuse(7/*Literal*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // Literal ::= STRLIT 
            {
        JTree RESULT = null;
        Constant l = (Constant)$stack[jcup$top].value;
        int lleft = $stack[jcup$top].left;
         RESULT = at(lleft, make.Literal(l));
              return jcup$stack.reuse(7/*Literal*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // Literal ::= DOUBLELIT 
            {
        JTree RESULT = null;
        Constant l = (Constant)$stack[jcup$top].value;
        int lleft = $stack[jcup$top].left;
         RESULT = at(lleft, make.Literal(l));
              return jcup$stack.reuse(7/*Literal*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // Literal ::= FLOATLIT 
            {
        JTree RESULT = null;
        Constant l = (Constant)$stack[jcup$top].value;
        int lleft = $stack[jcup$top].left;
         RESULT = at(lleft, make.Literal(l));
              return jcup$stack.reuse(7/*Literal*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // Literal ::= LONGLIT 
            {
        JTree RESULT = null;
        Constant l = (Constant)$stack[jcup$top].value;
        int lleft = $stack[jcup$top].left;
         RESULT = at(lleft, make.Literal(l));
              return jcup$stack.reuse(7/*Literal*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // Literal ::= INTLIT 
            {
        JTree RESULT = null;
        Constant l = (Constant)$stack[jcup$top].value;
        int lleft = $stack[jcup$top].left;
         RESULT = at(lleft, make.Literal(l));
              return jcup$stack.reuse(7/*Literal*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // Literal ::= CHARLIT 
            {
        JTree RESULT = null;
        Constant l = (Constant)$stack[jcup$top].value;
        int lleft = $stack[jcup$top].left;
         RESULT = at(lleft, make.Literal(l));
              return jcup$stack.reuse(7/*Literal*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // Name ::= IDENTIFIER 
            {
        JTree RESULT = null;
        Name i = (Name)$stack[jcup$top].value;
        int ileft = $stack[jcup$top].left;
         RESULT = at(ileft, make.Ident(i));
              return jcup$stack.reuse(11/*Name*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // SimpleTerm ::= TermTupel 
            {
        JTree RESULT = null;
        JTree t = (JTree)$stack[jcup$top].value;
         RESULT = t;
              return jcup$stack.reuse(6/*SimpleTerm*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // SimpleTerm ::= SimpleTerm DOT IDENTIFIER 
            {
        JTree RESULT = null;
        JTree q = (JTree)$stack[jcup$top-2].value;
        Object d = (Object)$stack[jcup$top-1].value;
        Name s = (Name)$stack[jcup$top].value;
        int dleft = $stack[jcup$top-1].left;
         RESULT = at(dleft, make.Select(q, s));
              return jcup$stack.reuse(6/*SimpleTerm*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // SimpleTerm ::= Literal 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top].value;
         RESULT = l;
              return jcup$stack.reuse(6/*SimpleTerm*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // SimpleTerm ::= Name 
            {
        JTree RESULT = null;
        JTree t = (JTree)$stack[jcup$top].value;
         RESULT = t;
              return jcup$stack.reuse(6/*SimpleTerm*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // UnaryExprTerm ::= MINUS SimpleTerm 
            {
        JTree RESULT = null;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Oper(JoinConst.NEG, null, r));
              return jcup$stack.reuse(15/*UnaryExprTerm*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // UnaryExprTerm ::= NOT SimpleTerm 
            {
        JTree RESULT = null;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Oper(JoinConst.NOT, null, r));
              return jcup$stack.reuse(15/*UnaryExprTerm*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // UnaryExprTerm ::= SimpleTerm 
            {
        JTree RESULT = null;
        JTree t = (JTree)$stack[jcup$top].value;
         RESULT = t;
              return jcup$stack.reuse(15/*UnaryExprTerm*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // ApplyTerm ::= ApplyTerm SimpleTerm 
            {
        JTree RESULT = null;
        JTree f = (JTree)$stack[jcup$top-1].value;
        JTree a = (JTree)$stack[jcup$top].value;
        int fleft = $stack[jcup$top-1].left;
         RESULT = at(fleft, make.Apply(f, a));
              return jcup$stack.reuse(5/*ApplyTerm*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // ApplyTerm ::= UnaryExprTerm 
            {
        JTree RESULT = null;
        JTree t = (JTree)$stack[jcup$top].value;
         RESULT = t;
              return jcup$stack.reuse(5/*ApplyTerm*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // ExpressionTerm ::= ExpressionTerm LTEQ ExpressionTerm 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Oper(JoinConst.LTEQ, l, r));
              return jcup$stack.reuse(4/*ExpressionTerm*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // ExpressionTerm ::= ExpressionTerm GTEQ ExpressionTerm 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Oper(JoinConst.GTEQ, l, r));
              return jcup$stack.reuse(4/*ExpressionTerm*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // ExpressionTerm ::= ExpressionTerm LT ExpressionTerm 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Oper(JoinConst.LT, l, r));
              return jcup$stack.reuse(4/*ExpressionTerm*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // ExpressionTerm ::= ExpressionTerm GT ExpressionTerm 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Oper(JoinConst.GT, l, r));
              return jcup$stack.reuse(4/*ExpressionTerm*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // ExpressionTerm ::= ExpressionTerm NOTEQ ExpressionTerm 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Oper(JoinConst.NOTEQ, l, r));
              return jcup$stack.reuse(4/*ExpressionTerm*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // ExpressionTerm ::= ExpressionTerm EQ ExpressionTerm 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Oper(JoinConst.EQ, l, r));
              return jcup$stack.reuse(4/*ExpressionTerm*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // ExpressionTerm ::= ExpressionTerm OR ExpressionTerm 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Oper(JoinConst.OR, l, r));
              return jcup$stack.reuse(4/*ExpressionTerm*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // ExpressionTerm ::= ExpressionTerm AND ExpressionTerm 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Oper(JoinConst.AND, l, r));
              return jcup$stack.reuse(4/*ExpressionTerm*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // ExpressionTerm ::= ExpressionTerm DIV ExpressionTerm 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Oper(JoinConst.DIV, l, r));
              return jcup$stack.reuse(4/*ExpressionTerm*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // ExpressionTerm ::= ExpressionTerm TIMES ExpressionTerm 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Oper(JoinConst.TIMES, l, r));
              return jcup$stack.reuse(4/*ExpressionTerm*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // ExpressionTerm ::= ExpressionTerm MINUS ExpressionTerm 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Oper(JoinConst.MINUS, l, r));
              return jcup$stack.reuse(4/*ExpressionTerm*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // ExpressionTerm ::= ExpressionTerm PLUS ExpressionTerm 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Oper(JoinConst.PLUS, l, r));
              return jcup$stack.reuse(4/*ExpressionTerm*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // ExpressionTerm ::= ApplyTerm 
            {
        JTree RESULT = null;
        JTree t = (JTree)$stack[jcup$top].value;
         RESULT = t;
              return jcup$stack.reuse(4/*ExpressionTerm*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // IfTerm ::= IF LPAREN Term RPAREN Term ELSE IfTerm 
            {
        JTree RESULT = null;
        Object i = (Object)$stack[jcup$top-6].value;
        JTree c = (JTree)$stack[jcup$top-4].value;
        JTree s = (JTree)$stack[jcup$top-2].value;
        JTree t = (JTree)$stack[jcup$top].value;
        int ileft = $stack[jcup$top-6].left;
         RESULT = at(ileft, make.If(c, s, t));
              return jcup$stack.reuse(3/*IfTerm*/, jcup$top - 6, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // IfTerm ::= ExpressionTerm 
            {
        JTree RESULT = null;
        JTree t = (JTree)$stack[jcup$top].value;
         RESULT = t;
              return jcup$stack.reuse(3/*IfTerm*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // SemicolonTerm ::= TopLevelDef SEMICOLON Term 
            {
        JTree RESULT = null;
        JTree d = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree t = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Let(d, t));
              return jcup$stack.reuse(2/*SemicolonTerm*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // SemicolonTerm ::= Term SEMICOLON Term 
            {
        JTree RESULT = null;
        JTree s = (JTree)$stack[jcup$top-2].value;
        JTree t = (JTree)$stack[jcup$top].value;
        int sleft = $stack[jcup$top-2].left;
         RESULT =
                at(sleft, make.Let(
                    at(sleft, make.Decls(new JTree[]{
                        at(sleft, make.Decl(anonVar(sleft), s))})),
                    t));
              return jcup$stack.reuse(2/*SemicolonTerm*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // SemicolonTerm ::= IfTerm 
            {
        JTree RESULT = null;
        JTree t = (JTree)$stack[jcup$top].value;
         RESULT = t;
              return jcup$stack.reuse(2/*SemicolonTerm*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // Term ::= Term AMPERSAND Term 
            {
        JTree RESULT = null;
        JTree l = (JTree)$stack[jcup$top-2].value;
        Object o = (Object)$stack[jcup$top-1].value;
        JTree r = (JTree)$stack[jcup$top].value;
        int oleft = $stack[jcup$top-1].left;
         RESULT = at(oleft, make.Join(l, r));
              return jcup$stack.reuse(1/*Term*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // Term ::= SemicolonTerm 
            {
        JTree RESULT = null;
        JTree t = (JTree)$stack[jcup$top].value;
         RESULT = t;
              return jcup$stack.reuse(1/*Term*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // TopLevel ::= Term 
            {
        JTree RESULT = null;
        JTree t = (JTree)$stack[jcup$top].value;
        int tleft = $stack[jcup$top].left;
         RESULT = at(tleft, make.TopLevel(new JTree[]{t}, null));
              return jcup$stack.reuse(16/*TopLevel*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= TopLevel EOF 
            {
      jaco.framework.parser.Symbol jcup$result;
        Object RESULT = null;
        JTree start_val = (JTree)$stack[jcup$top-1].value;
        RESULT = start_val;
              jcup$result = new jaco.framework.parser.Symbol(0/*$START*/, jcup$top - 1, jcup$top, RESULT);
          /* ACCEPT */
          jcup$parser.done_parsing();
          return jcup$result;
            }

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
};

