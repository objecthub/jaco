//----------------------------------------------------
// code was generated by JCUP V0.13
// Mon Nov 11 12:07:40 CET 2002
//----------------------------------------------------

package jaco.keris.grammar;

import jaco.java.struct.*;
import jaco.keris.struct.*;
import jaco.java.component.*;
import jaco.keris.component.*;
import jaco.java.grammar.*;
import jaco.framework.*;
import Constant.*;
import Tree.*;

public final class XParser extends jaco.framework.parser.LRParser {

  /** constructor */
  public XParser() { super(); }

  /** production table */
  protected static final short _production_table[][] = {
        {0, 2},     {1, 1},     {82, 1},     {82, 1},     {82, 1}, 
        {82, 1},     {82, 1},     {82, 1},     {83, 1},     {83, 1}, 
        {84, 1},     {84, 1},     {85, 1},     {85, 1},     {86, 1}, 
        {86, 1},     {86, 1},     {86, 1},     {86, 1},     {87, 1}, 
        {87, 1},     {88, 1},     {88, 1},     {88, 1},     {89, 1}, 
        {91, 2},     {91, 2},     {173, 3},     {90, 1},     {90, 3}, 
        {92, 1},     {92, 1},     {80, 1},     {80, 1},     {80, 1}, 
        {93, 3},     {93, 3},     {93, 3},     {2, 3},     {18, 0}, 
        {18, 1},     {20, 1},     {20, 2},     {19, 0},     {19, 1}, 
        {21, 1},     {21, 2},     {94, 0},     {94, 1},     {95, 3}, 
        {96, 1},     {96, 1},     {97, 3},     {98, 5},     {99, 1}, 
        {99, 1},     {99, 1},     {99, 1},     {99, 1},     {99, 1}, 
        {3, 0},     {3, 1},     {4, 1},     {4, 2},     {5, 1}, 
        {5, 1},     {5, 1},     {5, 1},     {5, 1},     {5, 1}, 
        {5, 1},     {5, 1},     {5, 1},     {5, 1},     {5, 1}, 
        {174, 5},     {174, 6},     {165, 6},     {165, 8},     {165, 8}, 
        {71, 3},     {71, 2},     {72, 0},     {72, 1},     {46, 1}, 
        {46, 2},     {47, 1},     {47, 1},     {47, 1},     {47, 1}, 
        {47, 1},     {47, 1},     {13, 4},     {13, 5},     {13, 7}, 
        {170, 2},     {170, 4},     {170, 4},     {170, 3},     {170, 5}, 
        {170, 5},     {172, 6},     {51, 1},     {51, 3},     {102, 3}, 
        {102, 6},     {167, 4},     {167, 6},     {167, 6},     {169, 4}, 
        {169, 6},     {171, 3},     {171, 5},     {166, 6},     {166, 8}, 
        {166, 8},     {73, 3},     {73, 2},     {74, 0},     {74, 1}, 
        {49, 1},     {49, 2},     {50, 1},     {50, 1},     {50, 2}, 
        {50, 1},     {50, 1},     {50, 1},     {100, 0},     {100, 1}, 
        {101, 2},     {54, 0},     {54, 2},     {55, 0},     {55, 2}, 
        {22, 1},     {22, 3},     {52, 1},     {52, 3},     {75, 0}, 
        {75, 2},     {70, 0},     {70, 2},     {48, 1},     {48, 3}, 
        {168, 1},     {168, 3},     {58, 3},     {58, 2},     {57, 0}, 
        {57, 1},     {23, 1},     {23, 2},     {24, 1},     {24, 1}, 
        {24, 1},     {24, 1},     {29, 1},     {29, 1},     {29, 1}, 
        {29, 1},     {25, 4},     {26, 1},     {26, 3},     {15, 1}, 
        {15, 3},     {104, 1},     {104, 3},     {103, 1},     {103, 1}, 
        {6, 2},     {7, 4},     {7, 4},     {8, 4},     {8, 3}, 
        {8, 3},     {53, 0},     {53, 1},     {36, 1},     {36, 3}, 
        {36, 2},     {14, 2},     {14, 3},     {60, 0},     {60, 1}, 
        {61, 2},     {27, 1},     {27, 3},     {59, 1},     {59, 1}, 
        {164, 2},     {9, 4},     {10, 4},     {10, 3},     {56, 3}, 
        {56, 4},     {56, 2},     {105, 5},     {105, 5},     {105, 7}, 
        {105, 7},     {175, 5},     {62, 0},     {62, 1},     {28, 2}, 
        {28, 3},     {63, 3},     {63, 2},     {64, 0},     {64, 1}, 
        {30, 1},     {30, 2},     {31, 1},     {31, 1},     {31, 1}, 
        {31, 1},     {31, 1},     {32, 1},     {11, 2},     {12, 4}, 
        {106, 2},     {106, 3},     {106, 3},     {106, 4},     {106, 2}, 
        {33, 1},     {33, 3},     {107, 3},     {107, 2},     {40, 0}, 
        {40, 1},     {34, 1},     {34, 2},     {35, 1},     {35, 1}, 
        {35, 1},     {35, 1},     {37, 2},     {39, 2},     {39, 3}, 
        {109, 1},     {109, 1},     {109, 1},     {109, 1},     {109, 1}, 
        {109, 1},     {110, 1},     {110, 1},     {110, 1},     {110, 1}, 
        {110, 1},     {111, 1},     {111, 1},     {111, 1},     {111, 1}, 
        {111, 1},     {111, 1},     {111, 1},     {111, 1},     {111, 1}, 
        {111, 1},     {111, 1},     {111, 1},     {163, 3},     {163, 5}, 
        {108, 1},     {112, 3},     {113, 3},     {114, 2},     {115, 1}, 
        {115, 1},     {115, 1},     {115, 1},     {115, 1},     {115, 1}, 
        {115, 1},     {116, 5},     {117, 7},     {118, 7},     {119, 5}, 
        {77, 3},     {77, 4},     {77, 2},     {41, 1},     {41, 2}, 
        {78, 2},     {79, 0},     {79, 1},     {42, 1},     {42, 2}, 
        {176, 0},     {120, 4},     {120, 2},     {160, 1},     {160, 1}, 
        {160, 1},     {121, 5},     {122, 5},     {123, 7},     {124, 9}, 
        {125, 9},     {66, 0},     {66, 1},     {65, 1},     {65, 1}, 
        {68, 0},     {68, 1},     {67, 1},     {43, 1},     {43, 3}, 
        {126, 2},     {126, 3},     {127, 2},     {127, 3},     {128, 3}, 
        {129, 3},     {130, 5},     {131, 3},     {131, 4},     {76, 0}, 
        {76, 1},     {44, 1},     {44, 2},     {132, 5},     {133, 2}, 
        {135, 1},     {135, 3},     {135, 1},     {135, 1},     {135, 1}, 
        {135, 1},     {135, 1},     {135, 3},     {134, 1},     {134, 1}, 
        {136, 5},     {136, 6},     {136, 7},     {136, 8},     {136, 7}, 
        {136, 8},     {69, 0},     {69, 1},     {45, 1},     {45, 3}, 
        {138, 4},     {138, 4},     {138, 4},     {138, 4},     {38, 1}, 
        {38, 2},     {139, 3},     {17, 0},     {17, 1},     {16, 2}, 
        {16, 3},     {137, 3},     {137, 3},     {137, 4},     {137, 4}, 
        {137, 3},     {140, 4},     {140, 6},     {140, 6},     {141, 4}, 
        {141, 4},     {141, 4},     {142, 1},     {142, 1},     {142, 1}, 
        {142, 1},     {145, 2},     {146, 2},     {143, 1},     {143, 1}, 
        {143, 2},     {143, 2},     {143, 1},     {144, 2},     {147, 2}, 
        {148, 1},     {148, 2},     {148, 2},     {148, 1},     {150, 5}, 
        {150, 4},     {150, 5},     {155, 1},     {155, 3},     {155, 3}, 
        {155, 3},     {155, 3},     {155, 3},     {158, 1},     {158, 3}, 
        {158, 3},     {158, 3},     {158, 3},     {158, 3},     {158, 3}, 
        {158, 3},     {158, 3},     {158, 3},     {158, 3},     {158, 3}, 
        {158, 3},     {158, 3},     {158, 3},     {158, 3},     {149, 1}, 
        {149, 5},     {153, 1},     {153, 1},     {151, 3},     {151, 3}, 
        {152, 1},     {152, 1},     {152, 1},     {81, 1},     {81, 1}, 
        {81, 1},     {81, 1},     {81, 1},     {81, 1},     {81, 1}, 
        {81, 1},     {81, 1},     {81, 1},     {81, 1},     {154, 0}, 
        {154, 1},     {159, 1},     {159, 1},     {156, 2},     {157, 2}, 
        {161, 2},     {162, 2}  };

  /** access to production table */
  public short[][] production_table() {return _production_table;}

  /** parse action table */
  protected static short[][] _action_table;

  /** access to parse action table */
  public short[][] action_table() {return _action_table;}

  /** reduce_goto table */
  protected static short[][] _reduce_table;

  /** access to reduce_goto table */
  public short[][] reduce_table() {return _reduce_table;}

  static {
    try {
      java.io.ObjectInputStream p = new java.io.ObjectInputStream(find_tables("jaco.keris.grammar.XParser"));
      _action_table = (short[][])p.readObject();
      _reduce_table = (short[][])p.readObject();
    }
    catch (Exception e) {
      throw new RuntimeException("unable to load parser tables: " + e);
    }
  }
  /** instance of action encapsulation class */
  protected XParserActions action_obj;

  /** action encapsulation object initializer */
  protected void init_actions()
  {
      actObj = (action_obj = new XParserActions(this, stack));
  }

  /** start state */
  public final int start_state() { return 0; }
  /** start production */
  public final int start_production() { return 0; }

  /** EOF Symbol index */
  public final int EOF_sym() { return 0; }

  /** error Symbol index */
  public final int error_sym() { return 1; }


  /** user initialization */
  public final void user_init() throws java.lang.Exception
  {

    action_obj.lexer = lexer;
    action_obj.trees = lexer.trees;
    action_obj.make = (XTree.Factory)trees.make;
    action_obj.report = report;

  }

  /** scan to get the next Symbol */
  public final jaco.framework.parser.Symbol scan()
    throws java.lang.Exception
  {

    Object  obj;
    switch (lexer.token)
    {
        case XSymbols.IDENTIFIER:
            obj = lexer.name;
            break;
                
        case XSymbols.CHARLITERAL:
            obj = mkConst.IntConst((int)lexer.intVal, TypeConst.CHAR);
            break;
            
        case XSymbols.INTLITERAL:
            obj = mkConst.IntConst((int)lexer.intVal);
            break;
            
        case XSymbols.LONGLITERAL:
            obj = mkConst.LongConst(lexer.intVal);
            break;
            
        case XSymbols.FLOATLITERAL:
            obj = mkConst.FloatConst((float)lexer.floatVal);
            break;
            
        case XSymbols.DOUBLELITERAL:
            obj = mkConst.DoubleConst(lexer.floatVal);
            break;
            
        case XSymbols.STRINGLITERAL:
            obj = mkConst.StringConst(lexer.name);
            break;
        
        default:
            obj = null;
    }
    jaco.framework.parser.Symbol    sym =
        new jaco.framework.parser.Symbol(lexer.token,
                                    lexer.pos,
                                    Position.encode(lexer.cline, lexer.ccol),
                                    obj);
    lexer.nextToken();
    return sym;

  }


/* other components of the jaco compiler
 */
    Scanner             lexer;
    ErrorHandler        report;
    Trees               trees;
    Constant.Factory    mkConst;
    
    
    public XParser(Scanner lexer)
    {
        this.trees = lexer.trees;
        this.lexer = lexer;
        this.report = lexer.report;
        this.mkConst = lexer.constants.make;
    }
    
    public void report_error(String message, Object info)
    {
        if ((info instanceof jaco.framework.parser.Symbol) &&
            (((jaco.framework.parser.Symbol)info).sym > 0))
        {
            if (((jaco.framework.parser.Symbol)info).left != -1)
                report.error(((jaco.framework.parser.Symbol)info).left,
                        message + " (" +
                        ((jaco.framework.parser.Symbol)info).sym + ")");
            else
                report.error(Position.NOPOS, message);
        }
        else
            report.error(Position.NOPOS, message);
    }
    
    public void report_fatal_error(String message, Object info) throws Exception
    {
        done_parsing();
        report_error("fatal error: " + message, info);
        throw new Exception();
    }
    
    public void syntax_error(jaco.framework.parser.Symbol cur_token)
    {
        report_error("syntax error", cur_token);
    }
    
    protected int error_sync_size()
    {
        return 2;
    }

};

/** jcup generated class to encapsulate user supplied action code.*/
class XParserActions implements jaco.framework.parser.ActionInterface {
  protected jaco.framework.parser.LRParser   jcup$parser;
  protected jaco.framework.parser.ParseStack jcup$stack;
  private final XParser parser;


    Trees               trees;
    XTree.Factory       make;
    Scanner             lexer;
    ErrorHandler        report;
    
/** to reduce amount of LALR(1)-grammar states, we use this switch,
 *  to toggle between argument lists for switch statements and
 *  other constructs
 */
    boolean             inCaseArg = false;
    
    
    Tree replaceArrayType(ArrayTypeTerm idx, Tree newType)
    {
        while ((idx.elemtype != null) &&
                (idx.elemtype instanceof ArrayTypeTerm))
            idx = (ArrayTypeTerm)idx.elemtype;
        Tree    oldType = idx.elemtype;
        idx.elemtype = newType;
        return oldType;
    }
    
    VarDecl[] varDeclArray(Tree[] trees)
    {
        if (trees == null)
            return null;
        else
        {
            VarDecl[]   decls = new VarDecl[trees.length];
            for (int i = 0; i < decls.length; i++)
                decls[i] = (VarDecl)trees[i];
            return decls;
        }
    }


  /** constructor */
  XParserActions(
    XParser parser,
    jaco.framework.parser.ParseStack stack)
  {
      this.parser = parser;
      jcup$parser = parser;
      jcup$stack = stack;
  }

  /** method with the actual generated action code. */
  public final jaco.framework.parser.Symbol doAction(
    int jcup$act_num,
    int jcup$top)
    throws java.lang.Exception
    {
      /* the parse stack */
      jaco.framework.parser.Symbol[] $stack = jcup$stack.stack;

      /* select the action based on the action number */
      switch (jcup$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 436: // RecoverAtParen ::= error RPAREN 
            {
		Tree RESULT = null;
		RESULT = trees.errorTree;
              return jcup$stack.reuse(162/*RecoverAtParen*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 435: // RecoverAtComma ::= error COMMA 
            {
		Tree RESULT = null;
		RESULT = trees.errorTree;
              return jcup$stack.reuse(161/*RecoverAtComma*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 434: // RecoverAtBrace ::= error RBRACE 
            {
		Tree RESULT = null;
		RESULT = trees.errorTree;
              return jcup$stack.reuse(157/*RecoverAtBrace*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 433: // RecoverAtSemi ::= error SEMI 
            {
		Tree RESULT = null;
		RESULT = trees.errorTree;
              return jcup$stack.reuse(156/*RecoverAtSemi*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 432: // ClassOrArray ::= ArrayType 
            {
              return jcup$stack.reuse(159/*ClassOrArray*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 431: // ClassOrArray ::= Name 
            {
              return jcup$stack.reuse(159/*ClassOrArray*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 430: // Expressionopt ::= Expression 
            {
              return jcup$stack.reuse(154/*Expressionopt*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 429: // Expressionopt ::= 
            {
		Tree RESULT = null;
		RESULT = null;
              return new jaco.framework.parser.Symbol(154/*Expressionopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 428: // AssignmentOperator ::= BAREQ 
            {
		Integer RESULT = null;
		RESULT = new Integer(OperatorConst.BITOR);
              return jcup$stack.reuse(81/*AssignmentOperator*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 427: // AssignmentOperator ::= CARETEQ 
            {
		Integer RESULT = null;
		RESULT = new Integer(OperatorConst.BITXOR);
              return jcup$stack.reuse(81/*AssignmentOperator*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 426: // AssignmentOperator ::= AMPEQ 
            {
		Integer RESULT = null;
		RESULT = new Integer(OperatorConst.BITAND);
              return jcup$stack.reuse(81/*AssignmentOperator*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 425: // AssignmentOperator ::= GTGTGTEQ 
            {
		Integer RESULT = null;
		RESULT = new Integer(OperatorConst.USR);
              return jcup$stack.reuse(81/*AssignmentOperator*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 424: // AssignmentOperator ::= GTGTEQ 
            {
		Integer RESULT = null;
		RESULT = new Integer(OperatorConst.SR);
              return jcup$stack.reuse(81/*AssignmentOperator*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 423: // AssignmentOperator ::= LTLTEQ 
            {
		Integer RESULT = null;
		RESULT = new Integer(OperatorConst.SL);
              return jcup$stack.reuse(81/*AssignmentOperator*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 422: // AssignmentOperator ::= SUBEQ 
            {
		Integer RESULT = null;
		RESULT = new Integer(OperatorConst.MINUS);
              return jcup$stack.reuse(81/*AssignmentOperator*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 421: // AssignmentOperator ::= PLUSEQ 
            {
		Integer RESULT = null;
		RESULT = new Integer(OperatorConst.PLUS);
              return jcup$stack.reuse(81/*AssignmentOperator*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 420: // AssignmentOperator ::= PERCENTEQ 
            {
		Integer RESULT = null;
		RESULT = new Integer(OperatorConst.MOD);
              return jcup$stack.reuse(81/*AssignmentOperator*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 419: // AssignmentOperator ::= SLASHEQ 
            {
		Integer RESULT = null;
		RESULT = new Integer(OperatorConst.DIV);
              return jcup$stack.reuse(81/*AssignmentOperator*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 418: // AssignmentOperator ::= STAREQ 
            {
		Integer RESULT = null;
		RESULT = new Integer(OperatorConst.TIMES);
              return jcup$stack.reuse(81/*AssignmentOperator*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 417: // LeftHandSide ::= ArrayAccess 
            {
              return jcup$stack.reuse(152/*LeftHandSide*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 416: // LeftHandSide ::= FieldAccess 
            {
              return jcup$stack.reuse(152/*LeftHandSide*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 415: // LeftHandSide ::= Name 
            {
              return jcup$stack.reuse(152/*LeftHandSide*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 414: // Assignment ::= LeftHandSide AssignmentOperator Expression 
            {
		Tree RESULT = null;
		Tree lhs = (Tree)$stack[jcup$top-2].value;
		Integer o = (Integer)$stack[jcup$top-1].value;
		Tree rhs = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Assignop(o.intValue(), lhs, rhs).at(oleft);
              return jcup$stack.reuse(151/*Assignment*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 413: // Assignment ::= LeftHandSide EQ Expression 
            {
		Tree RESULT = null;
		Tree lhs = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree rhs = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Assign(lhs, rhs).at(oleft);
              return jcup$stack.reuse(151/*Assignment*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 412: // Expression ::= Assignment 
            {
              return jcup$stack.reuse(153/*Expression*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 411: // Expression ::= ConditionalExpression 
            {
              return jcup$stack.reuse(153/*Expression*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 410: // ConditionalExpression ::= BinaryExpression QUES Expression COLON ConditionalExpression 
            {
		Tree RESULT = null;
		Tree c = (Tree)$stack[jcup$top-4].value;
		Object q = (Object)$stack[jcup$top-3].value;
		Tree e1 = (Tree)$stack[jcup$top-2].value;
		Tree e2 = (Tree)$stack[jcup$top].value;
		int qleft = $stack[jcup$top-3].left;
		
            RESULT = make.If(c, e1, e2).at(qleft);
              return jcup$stack.reuse(149/*ConditionalExpression*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 409: // ConditionalExpression ::= BinaryExpression 
            {
              return jcup$stack.reuse(149/*ConditionalExpression*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 408: // BinaryExpressionInclEq ::= BinaryExpressionInclEq STAR BinaryExpressionInclEq 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.TIMES, x, y).at(oleft);
              return jcup$stack.reuse(158/*BinaryExpressionInclEq*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 407: // BinaryExpressionInclEq ::= BinaryExpressionInclEq SLASH BinaryExpressionInclEq 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.DIV, x, y).at(oleft);
              return jcup$stack.reuse(158/*BinaryExpressionInclEq*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 406: // BinaryExpressionInclEq ::= BinaryExpressionInclEq PERCENT BinaryExpressionInclEq 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.MOD, x, y).at(oleft);
              return jcup$stack.reuse(158/*BinaryExpressionInclEq*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 405: // BinaryExpressionInclEq ::= BinaryExpressionInclEq PLUS BinaryExpressionInclEq 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.PLUS, x, y).at(oleft);
              return jcup$stack.reuse(158/*BinaryExpressionInclEq*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 404: // BinaryExpressionInclEq ::= BinaryExpressionInclEq SUB BinaryExpressionInclEq 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.MINUS, x, y).at(oleft);
              return jcup$stack.reuse(158/*BinaryExpressionInclEq*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 403: // BinaryExpressionInclEq ::= BinaryExpressionInclEq LTLT BinaryExpressionInclEq 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.SL, x, y).at(oleft);
              return jcup$stack.reuse(158/*BinaryExpressionInclEq*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 402: // BinaryExpressionInclEq ::= BinaryExpressionInclEq GTGT BinaryExpressionInclEq 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.SR, x, y).at(oleft);
              return jcup$stack.reuse(158/*BinaryExpressionInclEq*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 401: // BinaryExpressionInclEq ::= BinaryExpressionInclEq GTGTGT BinaryExpressionInclEq 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.USR, x, y).at(oleft);
              return jcup$stack.reuse(158/*BinaryExpressionInclEq*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 400: // BinaryExpressionInclEq ::= BinaryExpressionInclEq LT BinaryExpressionInclEq 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.LT, x, y).at(oleft);
              return jcup$stack.reuse(158/*BinaryExpressionInclEq*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 399: // BinaryExpressionInclEq ::= BinaryExpressionInclEq GT BinaryExpressionInclEq 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.GT, x, y).at(oleft);
              return jcup$stack.reuse(158/*BinaryExpressionInclEq*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 398: // BinaryExpressionInclEq ::= BinaryExpressionInclEq LTEQ BinaryExpressionInclEq 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.LE, x, y).at(oleft);
              return jcup$stack.reuse(158/*BinaryExpressionInclEq*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 397: // BinaryExpressionInclEq ::= BinaryExpressionInclEq GTEQ BinaryExpressionInclEq 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.GE, x, y).at(oleft);
              return jcup$stack.reuse(158/*BinaryExpressionInclEq*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 396: // BinaryExpressionInclEq ::= BinaryExpressionInclEq INSTANCEOF ClassOrArray 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Typeop(OperatorConst.TYPETEST, x, y).
                                                            at(oleft);
              return jcup$stack.reuse(158/*BinaryExpressionInclEq*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 395: // BinaryExpressionInclEq ::= BinaryExpressionInclEq EQEQ BinaryExpressionInclEq 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.EQ, x, y).at(oleft);
              return jcup$stack.reuse(158/*BinaryExpressionInclEq*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 394: // BinaryExpressionInclEq ::= BinaryExpressionInclEq BANGEQ BinaryExpressionInclEq 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.NE, x, y).at(oleft);
              return jcup$stack.reuse(158/*BinaryExpressionInclEq*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 393: // BinaryExpressionInclEq ::= UnaryExpression 
            {
              return jcup$stack.reuse(158/*BinaryExpressionInclEq*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 392: // BinaryExpression ::= BinaryExpression AMP BinaryExpression 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.BITAND, x, y).at(oleft);
              return jcup$stack.reuse(155/*BinaryExpression*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 391: // BinaryExpression ::= BinaryExpression CARET BinaryExpression 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.BITXOR, x, y).at(oleft);
              return jcup$stack.reuse(155/*BinaryExpression*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 390: // BinaryExpression ::= BinaryExpression BAR BinaryExpression 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.BITOR, x, y).at(oleft);
              return jcup$stack.reuse(155/*BinaryExpression*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 389: // BinaryExpression ::= BinaryExpression AMPAMP BinaryExpression 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.AND, x, y).at(oleft);
              return jcup$stack.reuse(155/*BinaryExpression*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 388: // BinaryExpression ::= BinaryExpression BARBAR BinaryExpression 
            {
		Tree RESULT = null;
		Tree x = (Tree)$stack[jcup$top-2].value;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree y = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Binop(OperatorConst.OR, x, y).at(oleft);
              return jcup$stack.reuse(155/*BinaryExpression*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 387: // BinaryExpression ::= BinaryExpressionInclEq 
            {
              return jcup$stack.reuse(155/*BinaryExpression*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 386: // CastExpression ::= LPAREN Name Dims RPAREN UnaryExpressionNotPlusMinus 
            {
		Tree RESULT = null;
		Object l = (Object)$stack[jcup$top-4].value;
		Tree n = (Tree)$stack[jcup$top-3].value;
		ArrayTypeTerm d = (ArrayTypeTerm)$stack[jcup$top-2].value;
		Tree e = (Tree)$stack[jcup$top].value;
		int lleft = $stack[jcup$top-4].left;
		
            if (d != null)
            {
                replaceArrayType(d, n);
                RESULT = make.Typeop(OperatorConst.TYPECAST, e, d).at(lleft);
            }
            else
                RESULT = make.Typeop(OperatorConst.TYPECAST, e, n).at(lleft);
              return jcup$stack.reuse(150/*CastExpression*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 385: // CastExpression ::= LPAREN Expression RPAREN UnaryExpressionNotPlusMinus 
            {
		Tree RESULT = null;
		Object l = (Object)$stack[jcup$top-3].value;
		Tree t = (Tree)$stack[jcup$top-2].value;
		Tree e = (Tree)$stack[jcup$top].value;
		int lleft = $stack[jcup$top-3].left;
		
            RESULT = make.Typeop(OperatorConst.TYPECAST, e, t).at(lleft);
              return jcup$stack.reuse(150/*CastExpression*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 384: // CastExpression ::= LPAREN PrimitiveType Dimsopt RPAREN UnaryExpression 
            {
		Tree RESULT = null;
		Object l = (Object)$stack[jcup$top-4].value;
		Tree t = (Tree)$stack[jcup$top-3].value;
		ArrayTypeTerm d = (ArrayTypeTerm)$stack[jcup$top-2].value;
		Tree e = (Tree)$stack[jcup$top].value;
		int lleft = $stack[jcup$top-4].left;
		
            if (d != null)
            {
                replaceArrayType(d, t);
                    RESULT = make.Typeop(OperatorConst.TYPECAST, e, d).at(lleft);
            }
            else
                RESULT = make.Typeop(OperatorConst.TYPECAST, e, t).at(lleft);
              return jcup$stack.reuse(150/*CastExpression*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 383: // UnaryExpressionNotPlusMinus ::= CastExpression 
            {
              return jcup$stack.reuse(148/*UnaryExpressionNotPlusMinus*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 382: // UnaryExpressionNotPlusMinus ::= BANG UnaryExpression 
            {
		Tree RESULT = null;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree e = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Unop(OperatorConst.NOT, e).at(oleft);
              return jcup$stack.reuse(148/*UnaryExpressionNotPlusMinus*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 381: // UnaryExpressionNotPlusMinus ::= TILDE UnaryExpression 
            {
		Tree RESULT = null;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree e = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Unop(OperatorConst.COMPL, e).at(oleft);
              return jcup$stack.reuse(148/*UnaryExpressionNotPlusMinus*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 380: // UnaryExpressionNotPlusMinus ::= PostfixExpression 
            {
              return jcup$stack.reuse(148/*UnaryExpressionNotPlusMinus*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 379: // PreDecrementExpression ::= SUBSUB UnaryExpression 
            {
		Tree RESULT = null;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree e = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Unop(OperatorConst.PREDEC, e).at(oleft);
              return jcup$stack.reuse(147/*PreDecrementExpression*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 378: // PreIncrementExpression ::= PLUSPLUS UnaryExpression 
            {
		Tree RESULT = null;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree e = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Unop(OperatorConst.PREINC, e).at(oleft);
              return jcup$stack.reuse(144/*PreIncrementExpression*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 377: // UnaryExpression ::= UnaryExpressionNotPlusMinus 
            {
              return jcup$stack.reuse(143/*UnaryExpression*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 376: // UnaryExpression ::= SUB UnaryExpression 
            {
		Tree RESULT = null;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree e = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Unop(OperatorConst.NEG, e).at(oleft);
              return jcup$stack.reuse(143/*UnaryExpression*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 375: // UnaryExpression ::= PLUS UnaryExpression 
            {
		Tree RESULT = null;
		Object o = (Object)$stack[jcup$top-1].value;
		Tree e = (Tree)$stack[jcup$top].value;
		int oleft = $stack[jcup$top-1].left;
		
            RESULT = make.Unop(OperatorConst.POS, e).at(oleft);
              return jcup$stack.reuse(143/*UnaryExpression*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 374: // UnaryExpression ::= PreDecrementExpression 
            {
              return jcup$stack.reuse(143/*UnaryExpression*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 373: // UnaryExpression ::= PreIncrementExpression 
            {
              return jcup$stack.reuse(143/*UnaryExpression*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 372: // PostDecrementExpression ::= PostfixExpression SUBSUB 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top-1].value;
		Object o = (Object)$stack[jcup$top].value;
		int oleft = $stack[jcup$top].left;
		
            RESULT = make.Unop(OperatorConst.POSTDEC, e).at(oleft);
              return jcup$stack.reuse(146/*PostDecrementExpression*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 371: // PostIncrementExpression ::= PostfixExpression PLUSPLUS 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top-1].value;
		Object o = (Object)$stack[jcup$top].value;
		int oleft = $stack[jcup$top].left;
		
            RESULT = make.Unop(OperatorConst.POSTINC, e).at(oleft);
              return jcup$stack.reuse(145/*PostIncrementExpression*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 370: // PostfixExpression ::= PostDecrementExpression 
            {
              return jcup$stack.reuse(142/*PostfixExpression*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 369: // PostfixExpression ::= PostIncrementExpression 
            {
              return jcup$stack.reuse(142/*PostfixExpression*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 368: // PostfixExpression ::= Name 
            {
              return jcup$stack.reuse(142/*PostfixExpression*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 367: // PostfixExpression ::= Primary 
            {
              return jcup$stack.reuse(142/*PostfixExpression*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 366: // ArrayAccess ::= error LBRACKET Expression RBRACKET 
            {
		Tree RESULT = null;
		RESULT = trees.errorTree;
              return jcup$stack.reuse(141/*ArrayAccess*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 365: // ArrayAccess ::= PrimaryNoNewArray LBRACKET Expression RBRACKET 
            {
		Tree RESULT = null;
		Tree e1 = (Tree)$stack[jcup$top-3].value;
		Object l = (Object)$stack[jcup$top-2].value;
		Tree e2 = (Tree)$stack[jcup$top-1].value;
		int lleft = $stack[jcup$top-2].left;
		
            RESULT = make.Index(e1, e2).at(lleft);
              return jcup$stack.reuse(141/*ArrayAccess*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 364: // ArrayAccess ::= Name LBRACKET Expression RBRACKET 
            {
		Tree RESULT = null;
		Tree n = (Tree)$stack[jcup$top-3].value;
		Object l = (Object)$stack[jcup$top-2].value;
		Tree e = (Tree)$stack[jcup$top-1].value;
		int lleft = $stack[jcup$top-2].left;
		
            RESULT = make.Index(n, e).at(lleft);
              return jcup$stack.reuse(141/*ArrayAccess*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 363: // MethodInvocation ::= SUPER DOT IDENTIFIER LPAREN ArgumentListopt RPAREN 
            {
		Tree RESULT = null;
		Object s = (Object)$stack[jcup$top-5].value;
		Object d = (Object)$stack[jcup$top-4].value;
		Name i = (Name)$stack[jcup$top-3].value;
		Object l = (Object)$stack[jcup$top-2].value;
		Tree[] a = (Tree[])$stack[jcup$top-1].value;
		int sleft = $stack[jcup$top-5].left;
		int dleft = $stack[jcup$top-4].left;
		int lleft = $stack[jcup$top-2].left;
		
            RESULT = make.Apply(make.Select(trees.Super().at(sleft), i).
                                                at(dleft), a).at(lleft);
              return jcup$stack.reuse(140/*MethodInvocation*/, jcup$top - 5, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 362: // MethodInvocation ::= Primary DOT IDENTIFIER LPAREN ArgumentListopt RPAREN 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top-5].value;
		Object k = (Object)$stack[jcup$top-4].value;
		Name i = (Name)$stack[jcup$top-3].value;
		Object l = (Object)$stack[jcup$top-2].value;
		Tree[] a = (Tree[])$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-4].left;
		int lleft = $stack[jcup$top-2].left;
		
            RESULT = make.Apply(make.Select(e, i).at(kleft), a).
                                at(lleft);
              return jcup$stack.reuse(140/*MethodInvocation*/, jcup$top - 5, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 361: // MethodInvocation ::= Name LPAREN ArgumentListopt RPAREN 
            {
		Tree RESULT = null;
		Tree n = (Tree)$stack[jcup$top-3].value;
		Object l = (Object)$stack[jcup$top-2].value;
		Tree[] a = (Tree[])$stack[jcup$top-1].value;
		int lleft = $stack[jcup$top-2].left;
		
            RESULT = make.Apply(n, a).at(lleft);
              return jcup$stack.reuse(140/*MethodInvocation*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 360: // FieldAccess ::= VOID DOT CLASS 
            {
		Tree RESULT = null;
		Object v = (Object)$stack[jcup$top-2].value;
		Object k = (Object)$stack[jcup$top].value;
		int vleft = $stack[jcup$top-2].left;
		int kleft = $stack[jcup$top].left;
		
            RESULT = trees.Class(make.BasicType(TypeConst.VOID).at(vleft)).
                            at(kleft);
              return jcup$stack.reuse(137/*FieldAccess*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 359: // FieldAccess ::= Name Dims DOT CLASS 
            {
		Tree RESULT = null;
		Tree n = (Tree)$stack[jcup$top-3].value;
		ArrayTypeTerm d = (ArrayTypeTerm)$stack[jcup$top-2].value;
		Object k = (Object)$stack[jcup$top].value;
		int kleft = $stack[jcup$top].left;
		
            replaceArrayType(d, n);
            RESULT = trees.Class(d).at(kleft);
              return jcup$stack.reuse(137/*FieldAccess*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 358: // FieldAccess ::= PrimitiveType Dimsopt DOT CLASS 
            {
		Tree RESULT = null;
		Tree t = (Tree)$stack[jcup$top-3].value;
		ArrayTypeTerm d = (ArrayTypeTerm)$stack[jcup$top-2].value;
		Object k = (Object)$stack[jcup$top].value;
		int kleft = $stack[jcup$top].left;
		
            if (d != null)
            {
                replaceArrayType(d, t);
                RESULT = trees.Class(d).at(kleft);
            }
            else
                RESULT = trees.Class(t).at(kleft);
              return jcup$stack.reuse(137/*FieldAccess*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 357: // FieldAccess ::= SUPER DOT IDENTIFIER 
            {
		Tree RESULT = null;
		Object s = (Object)$stack[jcup$top-2].value;
		Object k = (Object)$stack[jcup$top-1].value;
		Name i = (Name)$stack[jcup$top].value;
		int sleft = $stack[jcup$top-2].left;
		int kleft = $stack[jcup$top-1].left;
		
            RESULT = make.Select(trees.Super().at(sleft), i).at(kleft);
              return jcup$stack.reuse(137/*FieldAccess*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 356: // FieldAccess ::= Primary DOT IDENTIFIER 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top-2].value;
		Object k = (Object)$stack[jcup$top-1].value;
		Name i = (Name)$stack[jcup$top].value;
		int kleft = $stack[jcup$top-1].left;
		
            RESULT = make.Select(e, i).at(kleft);
              return jcup$stack.reuse(137/*FieldAccess*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 355: // Dims ::= Dims LBRACKET RBRACKET 
            {
		ArrayTypeTerm RESULT = null;
		ArrayTypeTerm d = (ArrayTypeTerm)$stack[jcup$top-2].value;
		Object l = (Object)$stack[jcup$top-1].value;
		int lleft = $stack[jcup$top-1].left;
		
            RESULT = (ArrayTypeTerm)make.ArrayTypeTerm(d).at(lleft);
              return jcup$stack.reuse(16/*Dims*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 354: // Dims ::= LBRACKET RBRACKET 
            {
		ArrayTypeTerm RESULT = null;
		Object l = (Object)$stack[jcup$top-1].value;
		int lleft = $stack[jcup$top-1].left;
		
            RESULT = (ArrayTypeTerm)make.ArrayTypeTerm(null).at(lleft);
              return jcup$stack.reuse(16/*Dims*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 353: // Dimsopt ::= Dims 
            {
              return jcup$stack.reuse(17/*Dimsopt*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 352: // Dimsopt ::= 
            {
		ArrayTypeTerm RESULT = null;
		RESULT = null;
              return new jaco.framework.parser.Symbol(17/*Dimsopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 351: // DimExpr ::= LBRACKET Expression RBRACKET 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top-1].value;
		 RESULT = e;
              return jcup$stack.reuse(139/*DimExpr*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 350: // DimExprs ::= DimExprs DimExpr 
            {
		TreeList RESULT = null;
		TreeList es = (TreeList)$stack[jcup$top-1].value;
		Tree e = (Tree)$stack[jcup$top].value;
		 RESULT = es.append(e);
              return jcup$stack.reuse(38/*DimExprs*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 349: // DimExprs ::= DimExpr 
            {
		TreeList RESULT = null;
		Tree e = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(e);
              return jcup$stack.reuse(38/*DimExprs*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 348: // ArrayCreationExpression ::= NEW ClassOrInterfaceType Dims ArrayInitializer 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-3].value;
		Tree t = (Tree)$stack[jcup$top-2].value;
		ArrayTypeTerm d = (ArrayTypeTerm)$stack[jcup$top-1].value;
		Tree i = (Tree)$stack[jcup$top].value;
		
            if (d != null)
            {
                replaceArrayType(d, t);
                ((Aggregate)i).arrtype = d;
                RESULT = i;
            }
            else
                ((Aggregate)i).arrtype = t;
            RESULT = i;
              return jcup$stack.reuse(138/*ArrayCreationExpression*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 347: // ArrayCreationExpression ::= NEW PrimitiveType Dims ArrayInitializer 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-3].value;
		Tree t = (Tree)$stack[jcup$top-2].value;
		ArrayTypeTerm d = (ArrayTypeTerm)$stack[jcup$top-1].value;
		Tree i = (Tree)$stack[jcup$top].value;
		
            if (d != null)
            {
                replaceArrayType(d, t);
                ((Aggregate)i).arrtype = d;
                RESULT = i;
            }
            else
                ((Aggregate)i).arrtype = t;
            RESULT = i;
              return jcup$stack.reuse(138/*ArrayCreationExpression*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 346: // ArrayCreationExpression ::= NEW ClassOrInterfaceType DimExprs Dimsopt 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-3].value;
		Tree t = (Tree)$stack[jcup$top-2].value;
		TreeList e = (TreeList)$stack[jcup$top-1].value;
		ArrayTypeTerm d = (ArrayTypeTerm)$stack[jcup$top].value;
		int kleft = $stack[jcup$top-3].left;
		
            if (d != null)
            {
                replaceArrayType(d, t);
                RESULT = make.NewArray(d, e.toArray()).at(kleft);
            }
            else
                RESULT = make.NewArray(t, e.toArray()).at(kleft);
              return jcup$stack.reuse(138/*ArrayCreationExpression*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 345: // ArrayCreationExpression ::= NEW PrimitiveType DimExprs Dimsopt 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-3].value;
		Tree t = (Tree)$stack[jcup$top-2].value;
		TreeList e = (TreeList)$stack[jcup$top-1].value;
		ArrayTypeTerm d = (ArrayTypeTerm)$stack[jcup$top].value;
		int kleft = $stack[jcup$top-3].left;
		
            if (d != null)
            {
                replaceArrayType(d, t);
                RESULT = make.NewArray(d, e.toArray()).at(kleft);
            }
            else
                RESULT = make.NewArray(t, e.toArray()).at(kleft);
              return jcup$stack.reuse(138/*ArrayCreationExpression*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 344: // ArgumentList ::= ArgumentList COMMA PatternParameter 
            {
		TreeList RESULT = null;
		TreeList as = (TreeList)$stack[jcup$top-2].value;
		Tree e = (Tree)$stack[jcup$top].value;
		 RESULT = as.append(e);
              return jcup$stack.reuse(45/*ArgumentList*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 343: // ArgumentList ::= PatternParameter 
            {
		TreeList RESULT = null;
		Tree e = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(e);
              return jcup$stack.reuse(45/*ArgumentList*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 342: // ArgumentListopt ::= ArgumentList 
            {
		Tree[] RESULT = null;
		TreeList as = (TreeList)$stack[jcup$top].value;
		 RESULT = as.toArray();
              return jcup$stack.reuse(69/*ArgumentListopt*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 341: // ArgumentListopt ::= 
            {
		Tree[] RESULT = null;
		RESULT = trees.noTrees;
              return new jaco.framework.parser.Symbol(69/*ArgumentListopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 340: // ClassInstanceCreationExpression ::= Name DOT NEW IDENTIFIER LPAREN ArgumentListopt RPAREN ClassBody 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top-7].value;
		Object k = (Object)$stack[jcup$top-5].value;
		Name i = (Name)$stack[jcup$top-4].value;
		Tree[] a = (Tree[])$stack[jcup$top-2].value;
		Tree[] b = (Tree[])$stack[jcup$top].value;
		int kleft = $stack[jcup$top-5].left;
		int ileft = $stack[jcup$top-4].left;
		int bleft = $stack[jcup$top].left;
		
            RESULT = make.NewObj(e, make.Ident(i).at(ileft), a,
                        make.ClassDecl(null, 0, null, trees.noTrees,
                            b).at(bleft)).at(kleft);
              return jcup$stack.reuse(136/*ClassInstanceCreationExpression*/, jcup$top - 7, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 339: // ClassInstanceCreationExpression ::= Name DOT NEW IDENTIFIER LPAREN ArgumentListopt RPAREN 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top-6].value;
		Object k = (Object)$stack[jcup$top-4].value;
		Name i = (Name)$stack[jcup$top-3].value;
		Tree[] a = (Tree[])$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-4].left;
		int ileft = $stack[jcup$top-3].left;
		
            RESULT = make.NewObj(e, make.Ident(i).at(ileft),
                            a, null).at(kleft);
              return jcup$stack.reuse(136/*ClassInstanceCreationExpression*/, jcup$top - 6, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 338: // ClassInstanceCreationExpression ::= Primary DOT NEW IDENTIFIER LPAREN ArgumentListopt RPAREN ClassBody 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top-7].value;
		Object k = (Object)$stack[jcup$top-5].value;
		Name i = (Name)$stack[jcup$top-4].value;
		Tree[] a = (Tree[])$stack[jcup$top-2].value;
		Tree[] b = (Tree[])$stack[jcup$top].value;
		int kleft = $stack[jcup$top-5].left;
		int ileft = $stack[jcup$top-4].left;
		int bleft = $stack[jcup$top].left;
		
            RESULT = make.NewObj(e, make.Ident(i).at(ileft), a,
                        make.ClassDecl(null, 0, null, trees.noTrees,
                            b).at(bleft)).at(kleft);
              return jcup$stack.reuse(136/*ClassInstanceCreationExpression*/, jcup$top - 7, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 337: // ClassInstanceCreationExpression ::= Primary DOT NEW IDENTIFIER LPAREN ArgumentListopt RPAREN 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top-6].value;
		Object k = (Object)$stack[jcup$top-4].value;
		Name i = (Name)$stack[jcup$top-3].value;
		Tree[] a = (Tree[])$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-4].left;
		int ileft = $stack[jcup$top-3].left;
		
            RESULT = make.NewObj(e, make.Ident(i).at(ileft),
                            a, null).at(kleft);
              return jcup$stack.reuse(136/*ClassInstanceCreationExpression*/, jcup$top - 6, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 336: // ClassInstanceCreationExpression ::= NEW ClassOrInterfaceType LPAREN ArgumentListopt RPAREN ClassBody 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-5].value;
		Tree t = (Tree)$stack[jcup$top-4].value;
		Tree[] a = (Tree[])$stack[jcup$top-2].value;
		Tree[] b = (Tree[])$stack[jcup$top].value;
		int kleft = $stack[jcup$top-5].left;
		int bleft = $stack[jcup$top].left;
		
            RESULT = make.NewObj(null, t, a,
                        make.ClassDecl(null, 0, null, trees.noTrees,
                            b).at(bleft)).at(kleft);
              return jcup$stack.reuse(136/*ClassInstanceCreationExpression*/, jcup$top - 5, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 335: // ClassInstanceCreationExpression ::= NEW ClassOrInterfaceType LPAREN ArgumentListopt RPAREN 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-4].value;
		Tree t = (Tree)$stack[jcup$top-3].value;
		Tree[] a = (Tree[])$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-4].left;
		
            RESULT = make.NewObj(null, t, a, null).at(kleft);
              return jcup$stack.reuse(136/*ClassInstanceCreationExpression*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 334: // Primary ::= ArrayCreationExpression 
            {
              return jcup$stack.reuse(134/*Primary*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 333: // Primary ::= PrimaryNoNewArray 
            {
              return jcup$stack.reuse(134/*Primary*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 332: // PrimaryNoNewArray ::= Name DOT THIS 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top-2].value;
		Object k = (Object)$stack[jcup$top].value;
		int kleft = $stack[jcup$top].left;
		
            RESULT = make.Self(e, TreeConst.THIS).at(kleft);
              return jcup$stack.reuse(135/*PrimaryNoNewArray*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 331: // PrimaryNoNewArray ::= THIS 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top].value;
		int kleft = $stack[jcup$top].left;
		RESULT=trees.This().at(kleft);
              return jcup$stack.reuse(135/*PrimaryNoNewArray*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 330: // PrimaryNoNewArray ::= ArrayAccess 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top].value;
		 RESULT = e;
              return jcup$stack.reuse(135/*PrimaryNoNewArray*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 329: // PrimaryNoNewArray ::= MethodInvocation 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top].value;
		 RESULT = e;
              return jcup$stack.reuse(135/*PrimaryNoNewArray*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 328: // PrimaryNoNewArray ::= FieldAccess 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top].value;
		 RESULT = e;
              return jcup$stack.reuse(135/*PrimaryNoNewArray*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 327: // PrimaryNoNewArray ::= ClassInstanceCreationExpression 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top].value;
		 RESULT = e;
              return jcup$stack.reuse(135/*PrimaryNoNewArray*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 326: // PrimaryNoNewArray ::= LPAREN Expression RPAREN 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top-1].value;
		 RESULT = e;
              return jcup$stack.reuse(135/*PrimaryNoNewArray*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 325: // PrimaryNoNewArray ::= Literal 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top].value;
		 RESULT = e;
              return jcup$stack.reuse(135/*PrimaryNoNewArray*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 324: // Finally ::= FINALLY Block 
            {
		Tree RESULT = null;
		Tree b = (Tree)$stack[jcup$top].value;
		 RESULT = b;
              return jcup$stack.reuse(133/*Finally*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 323: // CatchClause ::= CATCH LPAREN FormalParameter RPAREN Block 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-4].value;
		VarDecl f = (VarDecl)$stack[jcup$top-2].value;
		Tree b = (Tree)$stack[jcup$top].value;
		int kleft = $stack[jcup$top-4].left;
		
            RESULT = make.Catch(f, b).at(kleft);
              return jcup$stack.reuse(132/*CatchClause*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 322: // Catches ::= Catches CatchClause 
            {
		TreeList RESULT = null;
		TreeList cs = (TreeList)$stack[jcup$top-1].value;
		Tree c = (Tree)$stack[jcup$top].value;
		 RESULT = cs.append(c);
              return jcup$stack.reuse(44/*Catches*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 321: // Catches ::= CatchClause 
            {
		TreeList RESULT = null;
		Tree c = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(c);
              return jcup$stack.reuse(44/*Catches*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 320: // Catchesopt ::= Catches 
            {
		Catch[] RESULT = null;
		TreeList c = (TreeList)$stack[jcup$top].value;
		
            Tree[]      treess = c.toArray();
            Catch[]     catches = new Catch[treess.length];
            System.arraycopy(treess, 0, catches, 0, treess.length);
            RESULT = catches;
              return jcup$stack.reuse(76/*Catchesopt*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 319: // Catchesopt ::= 
            {
		Catch[] RESULT = null;
		RESULT = new Catch[0];
              return new jaco.framework.parser.Symbol(76/*Catchesopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 318: // TryStatement ::= TRY Block Catchesopt Finally 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-3].value;
		Tree b = (Tree)$stack[jcup$top-2].value;
		Catch[] c = (Catch[])$stack[jcup$top-1].value;
		Tree f = (Tree)$stack[jcup$top].value;
		int kleft = $stack[jcup$top-3].left;
		
            RESULT = make.Try(b, c, f).at(kleft);
              return jcup$stack.reuse(131/*TryStatement*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 317: // TryStatement ::= TRY Block Catches 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-2].value;
		Tree b = (Tree)$stack[jcup$top-1].value;
		TreeList c = (TreeList)$stack[jcup$top].value;
		int kleft = $stack[jcup$top-2].left;
		
            Tree[]      treess = c.toArray();
            Catch[]     catches = new Catch[treess.length];
            System.arraycopy(treess, 0, catches, 0, treess.length);
            RESULT = make.Try(b, catches, null).at(kleft);
              return jcup$stack.reuse(131/*TryStatement*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 316: // SynchronizedStatement ::= SYNCHRONIZED LPAREN Expression RPAREN Block 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-4].value;
		Tree e = (Tree)$stack[jcup$top-2].value;
		Tree b = (Tree)$stack[jcup$top].value;
		int kleft = $stack[jcup$top-4].left;
		
            RESULT = make.Synchronized(e, b).at(kleft);
              return jcup$stack.reuse(130/*SynchronizedStatement*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 315: // ThrowStatement ::= THROW Expression SEMI 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-2].value;
		Tree e = (Tree)$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-2].left;
		
            RESULT = make.Throw(e).at(kleft);
              return jcup$stack.reuse(129/*ThrowStatement*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 314: // ReturnStatement ::= RETURN Expressionopt SEMI 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-2].value;
		Tree e = (Tree)$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-2].left;
		
            RESULT = make.Return(e).at(kleft);
              return jcup$stack.reuse(128/*ReturnStatement*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 313: // ContinueStatement ::= CONTINUE IDENTIFIER SEMI 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-2].value;
		Name i = (Name)$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-2].left;
		
            RESULT = make.Continue(i).at(kleft);
              return jcup$stack.reuse(127/*ContinueStatement*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 312: // ContinueStatement ::= CONTINUE SEMI 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-1].left;
		
            RESULT = make.Continue(null).at(kleft);
              return jcup$stack.reuse(127/*ContinueStatement*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 311: // BreakStatement ::= BREAK IDENTIFIER SEMI 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-2].value;
		Name i = (Name)$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-2].left;
		
            RESULT = make.Break(i).at(kleft);
              return jcup$stack.reuse(126/*BreakStatement*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 310: // BreakStatement ::= BREAK SEMI 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-1].left;
		
            RESULT = make.Break(null).at(kleft);
              return jcup$stack.reuse(126/*BreakStatement*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 309: // StatementExpressionList ::= StatementExpressionList COMMA StatementExpression 
            {
		TreeList RESULT = null;
		TreeList es = (TreeList)$stack[jcup$top-2].value;
		Tree e = (Tree)$stack[jcup$top].value;
		
            RESULT = es.append(e);
              return jcup$stack.reuse(43/*StatementExpressionList*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 308: // StatementExpressionList ::= StatementExpression 
            {
		TreeList RESULT = null;
		Tree e = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(e);
              return jcup$stack.reuse(43/*StatementExpressionList*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 307: // ForUpdate ::= StatementExpressionList 
            {
		Tree[] RESULT = null;
		TreeList es = (TreeList)$stack[jcup$top].value;
		 RESULT = es.toArray();
              return jcup$stack.reuse(67/*ForUpdate*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 306: // ForUpdateopt ::= ForUpdate 
            {
              return jcup$stack.reuse(68/*ForUpdateopt*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 305: // ForUpdateopt ::= 
            {
		Tree[] RESULT = null;
		RESULT = trees.noTrees;
              return new jaco.framework.parser.Symbol(68/*ForUpdateopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 304: // ForInit ::= LocalVariableDeclaration 
            {
		Tree[] RESULT = null;
		TreeList vd = (TreeList)$stack[jcup$top].value;
		 RESULT = vd.toArray();
              return jcup$stack.reuse(65/*ForInit*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 303: // ForInit ::= StatementExpressionList 
            {
		Tree[] RESULT = null;
		TreeList ss = (TreeList)$stack[jcup$top].value;
		 RESULT = ss.toArray();
              return jcup$stack.reuse(65/*ForInit*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 302: // ForInitopt ::= ForInit 
            {
              return jcup$stack.reuse(66/*ForInitopt*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 301: // ForInitopt ::= 
            {
		Tree[] RESULT = null;
		RESULT = trees.noTrees;
              return new jaco.framework.parser.Symbol(66/*ForInitopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 300: // ForStatementNoShortIf ::= FOR LPAREN ForInitopt SEMI Expressionopt SEMI ForUpdateopt RPAREN StatementNoShortIf 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-8].value;
		Tree[] i = (Tree[])$stack[jcup$top-6].value;
		Tree e = (Tree)$stack[jcup$top-4].value;
		Tree[] u = (Tree[])$stack[jcup$top-2].value;
		Tree s = (Tree)$stack[jcup$top].value;
		int kleft = $stack[jcup$top-8].left;
		
            RESULT = make.ForLoop(i, e, u, s).at(kleft);
              return jcup$stack.reuse(125/*ForStatementNoShortIf*/, jcup$top - 8, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 299: // ForStatement ::= FOR LPAREN ForInitopt SEMI Expressionopt SEMI ForUpdateopt RPAREN Statement 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-8].value;
		Tree[] i = (Tree[])$stack[jcup$top-6].value;
		Tree e = (Tree)$stack[jcup$top-4].value;
		Tree[] u = (Tree[])$stack[jcup$top-2].value;
		Tree s = (Tree)$stack[jcup$top].value;
		int kleft = $stack[jcup$top-8].left;
		
            RESULT = make.ForLoop(i, e, u, s).at(kleft);
              return jcup$stack.reuse(124/*ForStatement*/, jcup$top - 8, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 298: // DoStatement ::= DO Statement WHILE LPAREN Expression RPAREN SEMI 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-6].value;
		Tree s = (Tree)$stack[jcup$top-5].value;
		Tree e = (Tree)$stack[jcup$top-2].value;
		int kleft = $stack[jcup$top-6].left;
		
            RESULT = make.Loop(TreeConst.DO, e, s).at(kleft);
              return jcup$stack.reuse(123/*DoStatement*/, jcup$top - 6, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 297: // WhileStatementNoShortIf ::= WHILE LPAREN Expression RPAREN StatementNoShortIf 
            {
		Tree RESULT = null;
		Object w = (Object)$stack[jcup$top-4].value;
		Tree e = (Tree)$stack[jcup$top-2].value;
		Tree s = (Tree)$stack[jcup$top].value;
		int wleft = $stack[jcup$top-4].left;
		
            RESULT = make.Loop(TreeConst.WHILE, e, s).at(wleft);
              return jcup$stack.reuse(122/*WhileStatementNoShortIf*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 296: // WhileStatement ::= WHILE LPAREN Expression RPAREN Statement 
            {
		Tree RESULT = null;
		Object w = (Object)$stack[jcup$top-4].value;
		Tree e = (Tree)$stack[jcup$top-2].value;
		Tree s = (Tree)$stack[jcup$top].value;
		int wleft = $stack[jcup$top-4].left;
		
            RESULT = make.Loop(TreeConst.WHILE, e, s).at(wleft);
              return jcup$stack.reuse(121/*WhileStatement*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 295: // PatternParameter ::= Expression 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top].value;
		 RESULT = e;
              return jcup$stack.reuse(160/*PatternParameter*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 294: // PatternParameter ::= FormalParameter 
            {
		Tree RESULT = null;
		VarDecl p = (VarDecl)$stack[jcup$top].value;
		int pleft = $stack[jcup$top].left;
		
            if (inCaseArg)
                RESULT = p;
            else
            {
                report.error(pleft, "pattern variables are only allowed in case patterns");
                RESULT = trees.errorTree;
            }
              return jcup$stack.reuse(160/*PatternParameter*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 293: // PatternParameter ::= SUBSCR 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top].value;
		int kleft = $stack[jcup$top].left;
		
            if (inCaseArg)
                RESULT = make.VarDecl(null, 0, null, null).at(kleft);
            else
            {
                report.error(kleft, "_ is only allowed in case patterns");
                RESULT = trees.errorTree;
            }
              return jcup$stack.reuse(160/*PatternParameter*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 292: // SwitchLabel ::= DEFAULT COLON 
            {
		Tree RESULT = null;
		RESULT = make.Exec(null);
              return jcup$stack.reuse(120/*SwitchLabel*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 291: // SwitchLabel ::= CASE NT$0 BinaryExpression COLON 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top-1].value;
		 inCaseArg = false; RESULT = make.Exec(e);
              return jcup$stack.reuse(120/*SwitchLabel*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 290: // NT$0 ::= 
            {
		Object RESULT = null;
		inCaseArg = true; RESULT = null;
              return new jaco.framework.parser.Symbol(176/*NT$0*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 289: // SwitchLabels ::= SwitchLabels SwitchLabel 
            {
		TreeList RESULT = null;
		TreeList ls = (TreeList)$stack[jcup$top-1].value;
		Tree l = (Tree)$stack[jcup$top].value;
		
            RESULT = ls.append(l);
              return jcup$stack.reuse(42/*SwitchLabels*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 288: // SwitchLabels ::= SwitchLabel 
            {
		TreeList RESULT = null;
		Tree l = (Tree)$stack[jcup$top].value;
		 RESULT = new TreeList(l);
              return jcup$stack.reuse(42/*SwitchLabels*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 287: // SwitchLabelsopt ::= SwitchLabels 
            {
		Case RESULT = null;
		TreeList ls = (TreeList)$stack[jcup$top].value;
		int lsleft = $stack[jcup$top].left;
		
            Tree[]  pats = ls.toArray();
            for (int i = 0; i < ls.length(); i++)
                if (pats[i] != null)
                    pats[i] = ((Exec)pats[i]).expr;
            RESULT = (Case)make.Case(pats, trees.noTrees).at(lsleft);
              return jcup$stack.reuse(79/*SwitchLabelsopt*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 286: // SwitchLabelsopt ::= 
            {
		Case RESULT = null;
		RESULT = null;
              return new jaco.framework.parser.Symbol(79/*SwitchLabelsopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 285: // SwitchBlockStatementGroup ::= SwitchLabels BlockStatements 
            {
		Case RESULT = null;
		TreeList ls = (TreeList)$stack[jcup$top-1].value;
		TreeList ss = (TreeList)$stack[jcup$top].value;
		int lsleft = $stack[jcup$top-1].left;
		
            Tree[]  pats = ls.toArray();
            for (int i = 0; i < ls.length(); i++)
                if (pats[i] != null)
                    pats[i] = ((Exec)pats[i]).expr;
            RESULT = (Case)make.Case(pats, ss.toArray()).at(lsleft);
              return jcup$stack.reuse(78/*SwitchBlockStatementGroup*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 284: // SwitchBlockStatementGroups ::= SwitchBlockStatementGroups SwitchBlockStatementGroup 
            {
		TreeList RESULT = null;
		TreeList ss = (TreeList)$stack[jcup$top-1].value;
		Case ss2 = (Case)$stack[jcup$top].value;
		
            RESULT = ss.append(ss2);
              return jcup$stack.reuse(41/*SwitchBlockStatementGroups*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 283: // SwitchBlockStatementGroups ::= SwitchBlockStatementGroup 
            {
		TreeList RESULT = null;
		Case s = (Case)$stack[jcup$top].value;
		 RESULT = trees.TreeList(s);
              return jcup$stack.reuse(41/*SwitchBlockStatementGroups*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 282: // SwitchBlock ::= LBRACE RecoverAtBrace 
            {
		Case[] RESULT = null;
		Tree err = (Tree)$stack[jcup$top].value;
		 RESULT = new Case[0];
              return jcup$stack.reuse(77/*SwitchBlock*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 281: // SwitchBlock ::= LBRACE SwitchBlockStatementGroups SwitchLabelsopt RBRACE 
            {
		Case[] RESULT = null;
		TreeList ls = (TreeList)$stack[jcup$top-2].value;
		Case ls2 = (Case)$stack[jcup$top-1].value;
		
            Tree[]  treess = ls.append(ls2).toArray();
            Case[]  cases = new Case[treess.length];
            System.arraycopy(treess, 0, cases, 0, treess.length);
            RESULT = cases;
              return jcup$stack.reuse(77/*SwitchBlock*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 280: // SwitchBlock ::= LBRACE SwitchLabelsopt RBRACE 
            {
		Case[] RESULT = null;
		Case l = (Case)$stack[jcup$top-1].value;
		
            if (l == null)
                RESULT = new Case[0];
            else
                RESULT = new Case[]{l};
              return jcup$stack.reuse(77/*SwitchBlock*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 279: // SwitchStatement ::= SWITCH LPAREN Expression RPAREN SwitchBlock 
            {
		Tree RESULT = null;
		Object s = (Object)$stack[jcup$top-4].value;
		Tree e = (Tree)$stack[jcup$top-2].value;
		Case[] b = (Case[])$stack[jcup$top].value;
		int sleft = $stack[jcup$top-4].left;
		
            RESULT = make.Switch(e, b).at(sleft);
              return jcup$stack.reuse(119/*SwitchStatement*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 278: // IfThenElseStatementNoShortIf ::= IF LPAREN Expression RPAREN StatementNoShortIf ELSE StatementNoShortIf 
            {
		Tree RESULT = null;
		Object i = (Object)$stack[jcup$top-6].value;
		Tree e = (Tree)$stack[jcup$top-4].value;
		Tree s1 = (Tree)$stack[jcup$top-2].value;
		Tree s2 = (Tree)$stack[jcup$top].value;
		int ileft = $stack[jcup$top-6].left;
		
            RESULT = make.If(e, s1, s2).at(ileft);
              return jcup$stack.reuse(118/*IfThenElseStatementNoShortIf*/, jcup$top - 6, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 277: // IfThenElseStatement ::= IF LPAREN Expression RPAREN StatementNoShortIf ELSE Statement 
            {
		Tree RESULT = null;
		Object i = (Object)$stack[jcup$top-6].value;
		Tree e = (Tree)$stack[jcup$top-4].value;
		Tree s1 = (Tree)$stack[jcup$top-2].value;
		Tree s2 = (Tree)$stack[jcup$top].value;
		int ileft = $stack[jcup$top-6].left;
		
            RESULT = make.If(e, s1, s2).at(ileft);
              return jcup$stack.reuse(117/*IfThenElseStatement*/, jcup$top - 6, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 276: // IfThenStatement ::= IF LPAREN Expression RPAREN Statement 
            {
		Tree RESULT = null;
		Object i = (Object)$stack[jcup$top-4].value;
		Tree e = (Tree)$stack[jcup$top-2].value;
		Tree s = (Tree)$stack[jcup$top].value;
		int ileft = $stack[jcup$top-4].left;
		
            RESULT = make.If(e, s, null).at(ileft);
              return jcup$stack.reuse(116/*IfThenStatement*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 275: // StatementExpression ::= ClassInstanceCreationExpression 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top].value;
		int eleft = $stack[jcup$top].left;
		
            RESULT = make.Exec(e).at(eleft);
              return jcup$stack.reuse(115/*StatementExpression*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 274: // StatementExpression ::= MethodInvocation 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top].value;
		int eleft = $stack[jcup$top].left;
		 RESULT = make.Exec(e).at(eleft);
              return jcup$stack.reuse(115/*StatementExpression*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 273: // StatementExpression ::= PostDecrementExpression 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top].value;
		int eleft = $stack[jcup$top].left;
		 RESULT = make.Exec(e).at(eleft);
              return jcup$stack.reuse(115/*StatementExpression*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 272: // StatementExpression ::= PostIncrementExpression 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top].value;
		int eleft = $stack[jcup$top].left;
		 RESULT = make.Exec(e).at(eleft);
              return jcup$stack.reuse(115/*StatementExpression*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 271: // StatementExpression ::= PreDecrementExpression 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top].value;
		int eleft = $stack[jcup$top].left;
		 RESULT = make.Exec(e).at(eleft);
              return jcup$stack.reuse(115/*StatementExpression*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 270: // StatementExpression ::= PreIncrementExpression 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top].value;
		int eleft = $stack[jcup$top].left;
		 RESULT = make.Exec(e).at(eleft);
              return jcup$stack.reuse(115/*StatementExpression*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 269: // StatementExpression ::= Assignment 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top].value;
		int eleft = $stack[jcup$top].left;
		 RESULT = make.Exec(e).at(eleft);
              return jcup$stack.reuse(115/*StatementExpression*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 268: // ExpressionStatement ::= StatementExpression SEMI 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top-1].value;
		 RESULT = e;
              return jcup$stack.reuse(114/*ExpressionStatement*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 267: // LabeledStatementNoShortIf ::= IDENTIFIER COLON StatementNoShortIf 
            {
		Tree RESULT = null;
		Name n = (Name)$stack[jcup$top-2].value;
		Object c = (Object)$stack[jcup$top-1].value;
		Tree s = (Tree)$stack[jcup$top].value;
		int cleft = $stack[jcup$top-1].left;
		
            RESULT = make.Labelled(n, s).at(cleft);
              return jcup$stack.reuse(113/*LabeledStatementNoShortIf*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 266: // LabeledStatement ::= IDENTIFIER COLON Statement 
            {
		Tree RESULT = null;
		Name n = (Name)$stack[jcup$top-2].value;
		Object c = (Object)$stack[jcup$top-1].value;
		Tree s = (Tree)$stack[jcup$top].value;
		int cleft = $stack[jcup$top-1].left;
		
            RESULT = make.Labelled(n, s).at(cleft);
              return jcup$stack.reuse(112/*LabeledStatement*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 265: // EmptyStatement ::= SEMI 
            {
		Tree RESULT = null;
		RESULT = null;
              return jcup$stack.reuse(108/*EmptyStatement*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 264: // AssertStatement ::= ASSERT Expression COLON Expression SEMI 
            {
		Tree RESULT = null;
		Object a = (Object)$stack[jcup$top-4].value;
		Tree e = (Tree)$stack[jcup$top-3].value;
		Tree f = (Tree)$stack[jcup$top-1].value;
		int aleft = $stack[jcup$top-4].left;
		
            RESULT = make.Assert(e, f).at(aleft);
              return jcup$stack.reuse(163/*AssertStatement*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 263: // AssertStatement ::= ASSERT Expression SEMI 
            {
		Tree RESULT = null;
		Object a = (Object)$stack[jcup$top-2].value;
		Tree e = (Tree)$stack[jcup$top-1].value;
		int aleft = $stack[jcup$top-2].left;
		
            RESULT = make.Assert(e, null).at(aleft);
              return jcup$stack.reuse(163/*AssertStatement*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 262: // StatementWithoutTrailingSubstatement ::= AssertStatement 
            {
              return jcup$stack.reuse(111/*StatementWithoutTrailingSubstatement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 261: // StatementWithoutTrailingSubstatement ::= EmptyStatement 
            {
              return jcup$stack.reuse(111/*StatementWithoutTrailingSubstatement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 260: // StatementWithoutTrailingSubstatement ::= TryStatement 
            {
              return jcup$stack.reuse(111/*StatementWithoutTrailingSubstatement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 259: // StatementWithoutTrailingSubstatement ::= ThrowStatement 
            {
              return jcup$stack.reuse(111/*StatementWithoutTrailingSubstatement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 258: // StatementWithoutTrailingSubstatement ::= SynchronizedStatement 
            {
              return jcup$stack.reuse(111/*StatementWithoutTrailingSubstatement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 257: // StatementWithoutTrailingSubstatement ::= ReturnStatement 
            {
              return jcup$stack.reuse(111/*StatementWithoutTrailingSubstatement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 256: // StatementWithoutTrailingSubstatement ::= ContinueStatement 
            {
              return jcup$stack.reuse(111/*StatementWithoutTrailingSubstatement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 255: // StatementWithoutTrailingSubstatement ::= BreakStatement 
            {
              return jcup$stack.reuse(111/*StatementWithoutTrailingSubstatement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 254: // StatementWithoutTrailingSubstatement ::= DoStatement 
            {
              return jcup$stack.reuse(111/*StatementWithoutTrailingSubstatement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 253: // StatementWithoutTrailingSubstatement ::= SwitchStatement 
            {
              return jcup$stack.reuse(111/*StatementWithoutTrailingSubstatement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 252: // StatementWithoutTrailingSubstatement ::= ExpressionStatement 
            {
              return jcup$stack.reuse(111/*StatementWithoutTrailingSubstatement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 251: // StatementWithoutTrailingSubstatement ::= Block 
            {
              return jcup$stack.reuse(111/*StatementWithoutTrailingSubstatement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 250: // StatementNoShortIf ::= ForStatementNoShortIf 
            {
              return jcup$stack.reuse(110/*StatementNoShortIf*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 249: // StatementNoShortIf ::= WhileStatementNoShortIf 
            {
              return jcup$stack.reuse(110/*StatementNoShortIf*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 248: // StatementNoShortIf ::= IfThenElseStatementNoShortIf 
            {
              return jcup$stack.reuse(110/*StatementNoShortIf*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 247: // StatementNoShortIf ::= LabeledStatementNoShortIf 
            {
              return jcup$stack.reuse(110/*StatementNoShortIf*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 246: // StatementNoShortIf ::= StatementWithoutTrailingSubstatement 
            {
              return jcup$stack.reuse(110/*StatementNoShortIf*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 245: // Statement ::= ForStatement 
            {
              return jcup$stack.reuse(109/*Statement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 244: // Statement ::= WhileStatement 
            {
              return jcup$stack.reuse(109/*Statement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 243: // Statement ::= IfThenElseStatement 
            {
              return jcup$stack.reuse(109/*Statement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 242: // Statement ::= IfThenStatement 
            {
              return jcup$stack.reuse(109/*Statement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 241: // Statement ::= LabeledStatement 
            {
              return jcup$stack.reuse(109/*Statement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 240: // Statement ::= StatementWithoutTrailingSubstatement 
            {
              return jcup$stack.reuse(109/*Statement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 239: // LocalVariableDeclaration ::= Modifiers Type VariableDeclarators 
            {
		TreeList RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-2].value;
		Tree t = (Tree)$stack[jcup$top-1].value;
		TreeList ds = (TreeList)$stack[jcup$top].value;
		
            int     mods = m.intValue();
            Tree[]  decls = ds.toArray();
            for (int i = 0; i < decls.length; i++)
            {
                VarDecl vd = (VarDecl)decls[i]; // fix declarations
                vd.mods = mods;
                if (vd.vartype instanceof ArrayTypeTerm)
                    vd.name = ((Ident)replaceArrayType(
                                    (ArrayTypeTerm)vd.vartype, t)).name;
                else
                {
                    vd.name = ((Ident)vd.vartype).name;
                    vd.vartype = t;
                }
            }
            RESULT = ds;
              return jcup$stack.reuse(39/*LocalVariableDeclaration*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 238: // LocalVariableDeclaration ::= Type VariableDeclarators 
            {
		TreeList RESULT = null;
		Tree t = (Tree)$stack[jcup$top-1].value;
		TreeList ds = (TreeList)$stack[jcup$top].value;
		
            Tree[]  decls = ds.toArray();
            for (int i = 0; i < decls.length; i++)
            {
                VarDecl vd = (VarDecl)decls[i]; // fix declarations
                if (vd.vartype instanceof ArrayTypeTerm)
                    vd.name = ((Ident)replaceArrayType(
                                    (ArrayTypeTerm)vd.vartype, t)).name;
                else
                {
                    vd.name = ((Ident)vd.vartype).name;
                    vd.vartype = t;
                }
            }
            RESULT = ds;
              return jcup$stack.reuse(39/*LocalVariableDeclaration*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 237: // LocalVariableDeclarationStatement ::= LocalVariableDeclaration SEMI 
            {
		TreeList RESULT = null;
		TreeList d = (TreeList)$stack[jcup$top-1].value;
		 RESULT = d;
              return jcup$stack.reuse(37/*LocalVariableDeclarationStatement*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 236: // BlockStatement ::= RecoverAtSemi 
            {
		TreeList RESULT = null;
		Tree err = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(err);
              return jcup$stack.reuse(35/*BlockStatement*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 235: // BlockStatement ::= ClassDeclaration 
            {
		TreeList RESULT = null;
		Tree s = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(s);
              return jcup$stack.reuse(35/*BlockStatement*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 234: // BlockStatement ::= Statement 
            {
		TreeList RESULT = null;
		Tree s = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(s);
              return jcup$stack.reuse(35/*BlockStatement*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 233: // BlockStatement ::= LocalVariableDeclarationStatement 
            {
              return jcup$stack.reuse(35/*BlockStatement*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 232: // BlockStatements ::= BlockStatements BlockStatement 
            {
		TreeList RESULT = null;
		TreeList bs = (TreeList)$stack[jcup$top-1].value;
		TreeList b = (TreeList)$stack[jcup$top].value;
		 RESULT = bs.append(b);
              return jcup$stack.reuse(34/*BlockStatements*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 231: // BlockStatements ::= BlockStatement 
            {
              return jcup$stack.reuse(34/*BlockStatements*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 230: // BlockStatementsopt ::= BlockStatements 
            {
              return jcup$stack.reuse(40/*BlockStatementsopt*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 229: // BlockStatementsopt ::= 
            {
		TreeList RESULT = null;
		RESULT = trees.TreeList();
              return new jaco.framework.parser.Symbol(40/*BlockStatementsopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 228: // Block ::= LBRACE RecoverAtBrace 
            {
		Tree RESULT = null;
		Tree err = (Tree)$stack[jcup$top].value;
		int errleft = $stack[jcup$top].left;
		
            RESULT = make.Block(0, new Tree[]{err}).at(errleft);
              return jcup$stack.reuse(107/*Block*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 227: // Block ::= LBRACE BlockStatementsopt RBRACE 
            {
		Tree RESULT = null;
		Object l = (Object)$stack[jcup$top-2].value;
		TreeList bs = (TreeList)$stack[jcup$top-1].value;
		int lleft = $stack[jcup$top-2].left;
		
            RESULT = make.Block(0, bs.toArray()).at(lleft);
              return jcup$stack.reuse(107/*Block*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 226: // VariableInitializers ::= VariableInitializers COMMA VariableInitializer 
            {
		TreeList RESULT = null;
		TreeList vs = (TreeList)$stack[jcup$top-2].value;
		Tree v = (Tree)$stack[jcup$top].value;
		
            RESULT = vs.append(v);
              return jcup$stack.reuse(33/*VariableInitializers*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 225: // VariableInitializers ::= VariableInitializer 
            {
		TreeList RESULT = null;
		Tree v = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(v);
              return jcup$stack.reuse(33/*VariableInitializers*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 224: // ArrayInitializer ::= LBRACE RecoverAtBrace 
            {
              return jcup$stack.reuse(106/*ArrayInitializer*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 223: // ArrayInitializer ::= LBRACE VariableInitializers COMMA RBRACE 
            {
		Tree RESULT = null;
		Object l = (Object)$stack[jcup$top-3].value;
		TreeList vs = (TreeList)$stack[jcup$top-2].value;
		int lleft = $stack[jcup$top-3].left;
		
            RESULT = make.Aggregate(vs.toArray(), null).at(lleft);
              return jcup$stack.reuse(106/*ArrayInitializer*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 222: // ArrayInitializer ::= LBRACE VariableInitializers RBRACE 
            {
		Tree RESULT = null;
		Object l = (Object)$stack[jcup$top-2].value;
		TreeList vs = (TreeList)$stack[jcup$top-1].value;
		int lleft = $stack[jcup$top-2].left;
		
            RESULT = make.Aggregate(vs.toArray(), null).at(lleft);
              return jcup$stack.reuse(106/*ArrayInitializer*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 221: // ArrayInitializer ::= LBRACE COMMA RBRACE 
            {
		Tree RESULT = null;
		Object l = (Object)$stack[jcup$top-2].value;
		int lleft = $stack[jcup$top-2].left;
		
            RESULT = make.Aggregate(trees.noTrees, null).at(lleft);
              return jcup$stack.reuse(106/*ArrayInitializer*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 220: // ArrayInitializer ::= LBRACE RBRACE 
            {
		Tree RESULT = null;
		Object l = (Object)$stack[jcup$top-1].value;
		int lleft = $stack[jcup$top-1].left;
		
            RESULT = make.Aggregate(trees.noTrees, null).at(lleft);
              return jcup$stack.reuse(106/*ArrayInitializer*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 219: // AbstractConstructorDeclaration ::= Modifiersopt ConstructorDeclarator Throwsopt SEMI 
            {
		MethodDecl RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-3].value;
		MethodDecl c = (MethodDecl)$stack[jcup$top-2].value;
		Tree[] t = (Tree[])$stack[jcup$top-1].value;
		
            c.mods = m.intValue();
            c.thrown = t;
            RESULT = c;
              return jcup$stack.reuse(12/*AbstractConstructorDeclaration*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 218: // AbstractMethodDeclaration ::= MethodHeader SEMI 
            {
		MethodDecl RESULT = null;
		MethodDecl m = (MethodDecl)$stack[jcup$top-1].value;
		 RESULT = m;
              return jcup$stack.reuse(11/*AbstractMethodDeclaration*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 217: // ConstantDeclaration ::= FieldDeclaration 
            {
              return jcup$stack.reuse(32/*ConstantDeclaration*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 216: // InterfaceMemberDeclaration ::= AbstractConstructorDeclaration 
            {
		TreeList RESULT = null;
		MethodDecl d = (MethodDecl)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(31/*InterfaceMemberDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 215: // InterfaceMemberDeclaration ::= InterfaceDeclaration 
            {
		TreeList RESULT = null;
		Tree d = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(31/*InterfaceMemberDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 214: // InterfaceMemberDeclaration ::= ClassDeclaration 
            {
		TreeList RESULT = null;
		Tree d = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(31/*InterfaceMemberDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 213: // InterfaceMemberDeclaration ::= AbstractMethodDeclaration 
            {
		TreeList RESULT = null;
		MethodDecl d = (MethodDecl)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(31/*InterfaceMemberDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 212: // InterfaceMemberDeclaration ::= ConstantDeclaration 
            {
              return jcup$stack.reuse(31/*InterfaceMemberDeclaration*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 211: // InterfaceMemberDeclarations ::= InterfaceMemberDeclarations InterfaceMemberDeclaration 
            {
		TreeList RESULT = null;
		TreeList ds = (TreeList)$stack[jcup$top-1].value;
		TreeList d = (TreeList)$stack[jcup$top].value;
		
            RESULT = ds.append(d);
              return jcup$stack.reuse(30/*InterfaceMemberDeclarations*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 210: // InterfaceMemberDeclarations ::= InterfaceMemberDeclaration 
            {
              return jcup$stack.reuse(30/*InterfaceMemberDeclarations*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 209: // InterfaceMemberDeclarationsopt ::= InterfaceMemberDeclarations 
            {
		Tree[] RESULT = null;
		TreeList is = (TreeList)$stack[jcup$top].value;
		 RESULT = is.toArray();
              return jcup$stack.reuse(64/*InterfaceMemberDeclarationsopt*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 208: // InterfaceMemberDeclarationsopt ::= 
            {
		Tree[] RESULT = null;
		RESULT = trees.noTrees;
              return new jaco.framework.parser.Symbol(64/*InterfaceMemberDeclarationsopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 207: // InterfaceBody ::= LBRACE RecoverAtBrace 
            {
		Tree[] RESULT = null;
		Tree err = (Tree)$stack[jcup$top].value;
		 RESULT = new Tree[]{err};
              return jcup$stack.reuse(63/*InterfaceBody*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 206: // InterfaceBody ::= LBRACE InterfaceMemberDeclarationsopt RBRACE 
            {
		Tree[] RESULT = null;
		Tree[] is = (Tree[])$stack[jcup$top-1].value;
		 RESULT = is;
              return jcup$stack.reuse(63/*InterfaceBody*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 205: // ExtendsInterfaces ::= ExtendsInterfaces COMMA ClassOrInterfaceType 
            {
		TreeList RESULT = null;
		TreeList ts = (TreeList)$stack[jcup$top-2].value;
		Tree t = (Tree)$stack[jcup$top].value;
		
            RESULT = ts.append(t);
              return jcup$stack.reuse(28/*ExtendsInterfaces*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 204: // ExtendsInterfaces ::= EXTENDS ClassOrInterfaceType 
            {
		TreeList RESULT = null;
		Tree t = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(t);
              return jcup$stack.reuse(28/*ExtendsInterfaces*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 203: // ExtendsInterfacesopt ::= ExtendsInterfaces 
            {
		Tree[] RESULT = null;
		TreeList is = (TreeList)$stack[jcup$top].value;
		 RESULT = is.toArray();
              return jcup$stack.reuse(62/*ExtendsInterfacesopt*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 202: // ExtendsInterfacesopt ::= 
            {
		Tree[] RESULT = null;
		RESULT = trees.noTrees;
              return new jaco.framework.parser.Symbol(62/*ExtendsInterfacesopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 201: // InterfaceDeclaration ::= Modifiersopt INTERFACE IDENTIFIER ExtendsInterfacesopt InterfaceBody 
            {
		Tree RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-4].value;
		Object k = (Object)$stack[jcup$top-3].value;
		Name n = (Name)$stack[jcup$top-2].value;
		Tree[] e = (Tree[])$stack[jcup$top-1].value;
		Tree[] ds = (Tree[])$stack[jcup$top].value;
		int kleft = $stack[jcup$top-3].left;
		
            RESULT = (ClassDecl)make.ClassDecl(n,
                        m.intValue() | ModifierConst.INTERFACE,
                        null, e, ds).at(kleft);
              return jcup$stack.reuse(175/*InterfaceDeclaration*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 200: // ExplicitConstructorInvocation ::= Name DOT SUPER LPAREN ArgumentListopt RPAREN SEMI 
            {
		Tree RESULT = null;
		Tree p = (Tree)$stack[jcup$top-6].value;
		Object s = (Object)$stack[jcup$top-4].value;
		Tree[] a = (Tree[])$stack[jcup$top-2].value;
		int pleft = $stack[jcup$top-6].left;
		int sleft = $stack[jcup$top-4].left;
		int aleft = $stack[jcup$top-2].left;
		
            RESULT = make.Exec(
                        make.Apply(make.Self(p, TreeConst.SUPER).at(sleft), a).at(aleft)).
                     at(pleft);
              return jcup$stack.reuse(105/*ExplicitConstructorInvocation*/, jcup$top - 6, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 199: // ExplicitConstructorInvocation ::= Primary DOT SUPER LPAREN ArgumentListopt RPAREN SEMI 
            {
		Tree RESULT = null;
		Tree p = (Tree)$stack[jcup$top-6].value;
		Object s = (Object)$stack[jcup$top-4].value;
		Tree[] a = (Tree[])$stack[jcup$top-2].value;
		int pleft = $stack[jcup$top-6].left;
		int sleft = $stack[jcup$top-4].left;
		int aleft = $stack[jcup$top-2].left;
		
            RESULT = make.Exec(
                        make.Apply(make.Self(p, TreeConst.SUPER).at(sleft), a).at(aleft)).
                     at(pleft);
              return jcup$stack.reuse(105/*ExplicitConstructorInvocation*/, jcup$top - 6, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 198: // ExplicitConstructorInvocation ::= SUPER LPAREN ArgumentListopt RPAREN SEMI 
            {
		Tree RESULT = null;
		Object s = (Object)$stack[jcup$top-4].value;
		Tree[] a = (Tree[])$stack[jcup$top-2].value;
		int sleft = $stack[jcup$top-4].left;
		int aleft = $stack[jcup$top-2].left;
		
            RESULT = make.Exec(
                        make.Apply(trees.Super().at(sleft), a).at(aleft)).
                     at(sleft);
              return jcup$stack.reuse(105/*ExplicitConstructorInvocation*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 197: // ExplicitConstructorInvocation ::= THIS LPAREN ArgumentListopt RPAREN SEMI 
            {
		Tree RESULT = null;
		Object s = (Object)$stack[jcup$top-4].value;
		Tree[] a = (Tree[])$stack[jcup$top-2].value;
		int sleft = $stack[jcup$top-4].left;
		int aleft = $stack[jcup$top-2].left;
		
            RESULT = make.Exec(
                        make.Apply(trees.This().at(sleft), a).at(aleft)).
                     at(sleft);
              return jcup$stack.reuse(105/*ExplicitConstructorInvocation*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 196: // ConstructorBody ::= LBRACE RecoverAtBrace 
            {
		Tree[] RESULT = null;
		Tree err = (Tree)$stack[jcup$top].value;
		
            RESULT = new Tree[]{err};
              return jcup$stack.reuse(56/*ConstructorBody*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 195: // ConstructorBody ::= LBRACE ExplicitConstructorInvocation BlockStatementsopt RBRACE 
            {
		Tree[] RESULT = null;
		Tree c = (Tree)$stack[jcup$top-2].value;
		TreeList s = (TreeList)$stack[jcup$top-1].value;
		
                RESULT = s.prepend(c).toArray();
              return jcup$stack.reuse(56/*ConstructorBody*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 194: // ConstructorBody ::= LBRACE BlockStatementsopt RBRACE 
            {
		Tree[] RESULT = null;
		TreeList s = (TreeList)$stack[jcup$top-1].value;
		
            RESULT = s.toArray();
              return jcup$stack.reuse(56/*ConstructorBody*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 193: // ConstructorDeclarator ::= SimpleName LPAREN RecoverAtParen 
            {
		MethodDecl RESULT = null;
		Name s = (Name)$stack[jcup$top-2].value;
		int sleft = $stack[jcup$top-2].left;
		
            RESULT = (MethodDecl)make.MethodDecl(s, 0, null, null, null, null).
                                            at(sleft);
              return jcup$stack.reuse(10/*ConstructorDeclarator*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 192: // ConstructorDeclarator ::= SimpleName LPAREN FormalParameterListopt RPAREN 
            {
		MethodDecl RESULT = null;
		Name s = (Name)$stack[jcup$top-3].value;
		VarDecl[] f = (VarDecl[])$stack[jcup$top-1].value;
		int sleft = $stack[jcup$top-3].left;
		
            RESULT = (MethodDecl)make.MethodDecl(s, 0, null, f, null, null).
                                            at(sleft);
              return jcup$stack.reuse(10/*ConstructorDeclarator*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 191: // ConstructorDeclaration ::= Modifiersopt ConstructorDeclarator Throwsopt ConstructorBody 
            {
		MethodDecl RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-3].value;
		MethodDecl c = (MethodDecl)$stack[jcup$top-2].value;
		Tree[] t = (Tree[])$stack[jcup$top-1].value;
		Tree[] s = (Tree[])$stack[jcup$top].value;
		
            // fix constructor declaration
            c.mods = m.intValue();
            c.thrown = t;
            c.stats = s;
            RESULT = c;
              return jcup$stack.reuse(9/*ConstructorDeclaration*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 190: // StaticInitializer ::= STATIC Block 
            {
		Tree RESULT = null;
		Tree s = (Tree)$stack[jcup$top].value;
		
            ((Block)s).mods |= ModifierConst.STATIC;
            RESULT = s;
              return jcup$stack.reuse(164/*StaticInitializer*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 189: // MethodBody ::= SEMI 
            {
		Tree[] RESULT = null;
		RESULT = null;
              return jcup$stack.reuse(59/*MethodBody*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 188: // MethodBody ::= Block 
            {
		Tree[] RESULT = null;
		Tree s = (Tree)$stack[jcup$top].value;
		 RESULT = ((Block)s).stats;
              return jcup$stack.reuse(59/*MethodBody*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 187: // ClassTypeList ::= ClassTypeList COMMA ClassOrInterfaceType 
            {
		TreeList RESULT = null;
		TreeList ts = (TreeList)$stack[jcup$top-2].value;
		Tree t = (Tree)$stack[jcup$top].value;
		
            RESULT = ts.append(t);
              return jcup$stack.reuse(27/*ClassTypeList*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // ClassTypeList ::= ClassOrInterfaceType 
            {
		TreeList RESULT = null;
		Tree t = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(t);
              return jcup$stack.reuse(27/*ClassTypeList*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // Throws ::= THROWS ClassTypeList 
            {
		Tree[] RESULT = null;
		TreeList ts = (TreeList)$stack[jcup$top].value;
		 RESULT = ts.toArray();
              return jcup$stack.reuse(61/*Throws*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // Throwsopt ::= Throws 
            {
              return jcup$stack.reuse(60/*Throwsopt*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // Throwsopt ::= 
            {
		Tree[] RESULT = null;
		RESULT = trees.noTrees;
              return new jaco.framework.parser.Symbol(60/*Throwsopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // FormalParameter ::= Modifiers Type VariableDeclaratorId 
            {
		VarDecl RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-2].value;
		Tree t = (Tree)$stack[jcup$top-1].value;
		Tree v = (Tree)$stack[jcup$top].value;
		int tleft = $stack[jcup$top-1].left;
		
            if (v instanceof ArrayTypeTerm)
            {
                RESULT = (VarDecl)make.VarDecl(((Ident)
                                replaceArrayType((ArrayTypeTerm)v, t)).name,
                                        m.intValue(), v, null).at(tleft);
            }
            else
                RESULT = (VarDecl)make.VarDecl(((Ident)v).name,
                                m.intValue(), t, null).at(tleft);
              return jcup$stack.reuse(14/*FormalParameter*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // FormalParameter ::= Type VariableDeclaratorId 
            {
		VarDecl RESULT = null;
		Tree t = (Tree)$stack[jcup$top-1].value;
		Tree v = (Tree)$stack[jcup$top].value;
		int tleft = $stack[jcup$top-1].left;
		
            if (v instanceof ArrayTypeTerm)
            {
                RESULT = (VarDecl)make.VarDecl(((Ident)
                    replaceArrayType((ArrayTypeTerm)v, t)).name, 0, v, null).
                        at(tleft);
            }
            else
                RESULT = (VarDecl)make.VarDecl(((Ident)v).name, 0, t,
                    null).at(tleft);
              return jcup$stack.reuse(14/*FormalParameter*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // FormalParameterList ::= RecoverAtComma FormalParameter 
            {
		TreeList RESULT = null;
		VarDecl f = (VarDecl)$stack[jcup$top].value;
		
            RESULT = trees.TreeList(f);
              return jcup$stack.reuse(36/*FormalParameterList*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // FormalParameterList ::= FormalParameterList COMMA FormalParameter 
            {
		TreeList RESULT = null;
		TreeList fs = (TreeList)$stack[jcup$top-2].value;
		VarDecl f = (VarDecl)$stack[jcup$top].value;
		
            RESULT = fs.append(f);
              return jcup$stack.reuse(36/*FormalParameterList*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // FormalParameterList ::= FormalParameter 
            {
		TreeList RESULT = null;
		VarDecl f = (VarDecl)$stack[jcup$top].value;
		 RESULT = trees.TreeList(f);
              return jcup$stack.reuse(36/*FormalParameterList*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // FormalParameterListopt ::= FormalParameterList 
            {
		VarDecl[] RESULT = null;
		TreeList f = (TreeList)$stack[jcup$top].value;
		 RESULT = varDeclArray(f.toArray());
              return jcup$stack.reuse(53/*FormalParameterListopt*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // FormalParameterListopt ::= 
            {
		VarDecl[] RESULT = null;
		RESULT = new VarDecl[0];
              return new jaco.framework.parser.Symbol(53/*FormalParameterListopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // MethodDeclarator ::= IDENTIFIER LPAREN RecoverAtParen 
            {
		MethodDecl RESULT = null;
		Name n = (Name)$stack[jcup$top-2].value;
		int nleft = $stack[jcup$top-2].left;
		
            RESULT = (MethodDecl)make.MethodDecl(n, 0, null, null, null, null).
                                            at(nleft);
              return jcup$stack.reuse(8/*MethodDeclarator*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // MethodDeclarator ::= MethodDeclarator LBRACKET RBRACKET 
            {
		MethodDecl RESULT = null;
		MethodDecl d = (MethodDecl)$stack[jcup$top-2].value;
		Object a = (Object)$stack[jcup$top-1].value;
		int aleft = $stack[jcup$top-1].left;
		
            d.restype = make.ArrayTypeTerm(d.restype).at(aleft);
            RESULT = d;
              return jcup$stack.reuse(8/*MethodDeclarator*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // MethodDeclarator ::= IDENTIFIER LPAREN FormalParameterListopt RPAREN 
            {
		MethodDecl RESULT = null;
		Name n = (Name)$stack[jcup$top-3].value;
		VarDecl[] p = (VarDecl[])$stack[jcup$top-1].value;
		int nleft = $stack[jcup$top-3].left;
		
            RESULT = (MethodDecl)make.MethodDecl(n, 0, null, p, null, null).
                                            at(nleft);
              return jcup$stack.reuse(8/*MethodDeclarator*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // MethodHeader ::= Modifiersopt VOID MethodDeclarator Throwsopt 
            {
		MethodDecl RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-3].value;
		Object v = (Object)$stack[jcup$top-2].value;
		MethodDecl d = (MethodDecl)$stack[jcup$top-1].value;
		Tree[] e = (Tree[])$stack[jcup$top].value;
		int vleft = $stack[jcup$top-2].left;
		
            d.mods = m.intValue();
            if (d.restype instanceof ArrayTypeTerm)
                replaceArrayType((ArrayTypeTerm)d.restype,
                                make.BasicType(TypeConst.VOID).at(vleft));
            else
                d.restype = make.BasicType(TypeConst.VOID).at(vleft);
            d.thrown = e;
            RESULT = d;
              return jcup$stack.reuse(7/*MethodHeader*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // MethodHeader ::= Modifiersopt Type MethodDeclarator Throwsopt 
            {
		MethodDecl RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-3].value;
		Tree t = (Tree)$stack[jcup$top-2].value;
		MethodDecl d = (MethodDecl)$stack[jcup$top-1].value;
		Tree[] e = (Tree[])$stack[jcup$top].value;
		
            // fix method declaration
            d.mods = m.intValue();
            if (d.restype instanceof ArrayTypeTerm)
                replaceArrayType((ArrayTypeTerm)d.restype, t);
            else
                d.restype = t;
            d.thrown = e;
            RESULT = d;
              return jcup$stack.reuse(7/*MethodHeader*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // MethodDeclaration ::= MethodHeader MethodBody 
            {
		MethodDecl RESULT = null;
		MethodDecl h = (MethodDecl)$stack[jcup$top-1].value;
		Tree[] s = (Tree[])$stack[jcup$top].value;
		 h.stats = s; RESULT = h;
              return jcup$stack.reuse(6/*MethodDeclaration*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // VariableInitializer ::= ArrayInitializer 
            {
              return jcup$stack.reuse(103/*VariableInitializer*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // VariableInitializer ::= Expression 
            {
              return jcup$stack.reuse(103/*VariableInitializer*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // VariableDeclaratorId ::= VariableDeclaratorId LBRACKET RBRACKET 
            {
		Tree RESULT = null;
		Tree n = (Tree)$stack[jcup$top-2].value;
		int nleft = $stack[jcup$top-2].left;
		
            RESULT = make.ArrayTypeTerm(n).at(nleft);
              return jcup$stack.reuse(104/*VariableDeclaratorId*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // VariableDeclaratorId ::= IDENTIFIER 
            {
		Tree RESULT = null;
		Name n = (Name)$stack[jcup$top].value;
		int nleft = $stack[jcup$top].left;
		 RESULT = make.Ident(n).at(nleft);
              return jcup$stack.reuse(104/*VariableDeclaratorId*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // VariableDeclarator ::= VariableDeclaratorId EQ VariableInitializer 
            {
		VarDecl RESULT = null;
		Tree n = (Tree)$stack[jcup$top-2].value;
		Tree i = (Tree)$stack[jcup$top].value;
		int nleft = $stack[jcup$top-2].left;
		
            RESULT = (VarDecl)make.VarDecl(null, 0, n, i).at(nleft);
              return jcup$stack.reuse(15/*VariableDeclarator*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // VariableDeclarator ::= VariableDeclaratorId 
            {
		VarDecl RESULT = null;
		Tree n = (Tree)$stack[jcup$top].value;
		int nleft = $stack[jcup$top].left;
		
            RESULT = (VarDecl)make.VarDecl(null, 0, n, null).at(nleft);
              return jcup$stack.reuse(15/*VariableDeclarator*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // VariableDeclarators ::= VariableDeclarators COMMA VariableDeclarator 
            {
		TreeList RESULT = null;
		TreeList vs = (TreeList)$stack[jcup$top-2].value;
		VarDecl v = (VarDecl)$stack[jcup$top].value;
		
            RESULT = vs.append(v);
              return jcup$stack.reuse(26/*VariableDeclarators*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // VariableDeclarators ::= VariableDeclarator 
            {
		TreeList RESULT = null;
		VarDecl v = (VarDecl)$stack[jcup$top].value;
		 RESULT = trees.TreeList(v);
              return jcup$stack.reuse(26/*VariableDeclarators*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // FieldDeclaration ::= Modifiersopt Type VariableDeclarators SEMI 
            {
		TreeList RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-3].value;
		Tree t = (Tree)$stack[jcup$top-2].value;
		TreeList ds = (TreeList)$stack[jcup$top-1].value;
		
            int     mods = m.intValue();
            Tree[]  decls = ds.toArray();
            for (int i = 0; i < decls.length; i++)
            {
                VarDecl vd = (VarDecl)decls[i]; // fix declarations
                vd.mods = mods;
                if (vd.vartype instanceof ArrayTypeTerm)
                    vd.name = ((Ident)replaceArrayType(
                                    (ArrayTypeTerm)vd.vartype, t)).name;
                else
                {
                    vd.name = ((Ident)vd.vartype).name;
                    vd.vartype = t;
                }
            }
            RESULT = ds;
              return jcup$stack.reuse(25/*FieldDeclaration*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // ClassMemberDeclaration ::= InterfaceDeclaration 
            {
		TreeList RESULT = null;
		Tree d = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(29/*ClassMemberDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // ClassMemberDeclaration ::= ClassDeclaration 
            {
		TreeList RESULT = null;
		Tree d = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(29/*ClassMemberDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // ClassMemberDeclaration ::= MethodDeclaration 
            {
		TreeList RESULT = null;
		MethodDecl d = (MethodDecl)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(29/*ClassMemberDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // ClassMemberDeclaration ::= FieldDeclaration 
            {
              return jcup$stack.reuse(29/*ClassMemberDeclaration*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // ClassBodyDeclaration ::= Block 
            {
		TreeList RESULT = null;
		Tree d = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(24/*ClassBodyDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // ClassBodyDeclaration ::= ConstructorDeclaration 
            {
		TreeList RESULT = null;
		MethodDecl d = (MethodDecl)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(24/*ClassBodyDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // ClassBodyDeclaration ::= StaticInitializer 
            {
		TreeList RESULT = null;
		Tree d = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(24/*ClassBodyDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // ClassBodyDeclaration ::= ClassMemberDeclaration 
            {
              return jcup$stack.reuse(24/*ClassBodyDeclaration*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // ClassBodyDeclarations ::= ClassBodyDeclarations ClassBodyDeclaration 
            {
		TreeList RESULT = null;
		TreeList ds = (TreeList)$stack[jcup$top-1].value;
		TreeList d = (TreeList)$stack[jcup$top].value;
		
            RESULT = ds.append(d);
              return jcup$stack.reuse(23/*ClassBodyDeclarations*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // ClassBodyDeclarations ::= ClassBodyDeclaration 
            {
              return jcup$stack.reuse(23/*ClassBodyDeclarations*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // ClassBodyDeclarationsopt ::= ClassBodyDeclarations 
            {
		Tree[] RESULT = null;
		TreeList ds = (TreeList)$stack[jcup$top].value;
		 RESULT = ds.toArray();
              return jcup$stack.reuse(57/*ClassBodyDeclarationsopt*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // ClassBodyDeclarationsopt ::= 
            {
		Tree[] RESULT = null;
		RESULT = trees.noTrees;
              return new jaco.framework.parser.Symbol(57/*ClassBodyDeclarationsopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // ClassBody ::= LBRACE RecoverAtBrace 
            {
		Tree[] RESULT = null;
		Tree err = (Tree)$stack[jcup$top].value;
		 RESULT = new Tree[]{err};
              return jcup$stack.reuse(58/*ClassBody*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // ClassBody ::= LBRACE ClassBodyDeclarationsopt RBRACE 
            {
		Tree[] RESULT = null;
		Tree[] ds = (Tree[])$stack[jcup$top-1].value;
		 RESULT = ds;
              return jcup$stack.reuse(58/*ClassBody*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // ModuleListElem ::= SimpleQualifiedName AS SimpleQualifiedName 
            {
		Tree RESULT = null;
		Tree t = (Tree)$stack[jcup$top-2].value;
		Object k = (Object)$stack[jcup$top-1].value;
		Tree i = (Tree)$stack[jcup$top].value;
		int kleft = $stack[jcup$top-1].left;
		
            RESULT = make.Overrides(t, new Tree[]{i}).at(kleft);
              return jcup$stack.reuse(168/*ModuleListElem*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // ModuleListElem ::= SimpleQualifiedName 
            {
		Tree RESULT = null;
		Tree t = (Tree)$stack[jcup$top].value;
		
            RESULT = t;
              return jcup$stack.reuse(168/*ModuleListElem*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // ModuleList ::= ModuleList COMMA ModuleListElem 
            {
		TreeList RESULT = null;
		TreeList is = (TreeList)$stack[jcup$top-2].value;
		Tree i = (Tree)$stack[jcup$top].value;
		
            RESULT = is.append(i);
              return jcup$stack.reuse(48/*ModuleList*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // ModuleList ::= ModuleListElem 
            {
		TreeList RESULT = null;
		Tree i = (Tree)$stack[jcup$top].value;
		
            RESULT = trees.TreeList(i);
              return jcup$stack.reuse(48/*ModuleList*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // RequiresAsopt ::= REQUIRES ModuleList 
            {
		Tree[] RESULT = null;
		TreeList i = (TreeList)$stack[jcup$top].value;
		 RESULT = i.toArray();
              return jcup$stack.reuse(70/*RequiresAsopt*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // RequiresAsopt ::= 
            {
		Tree[] RESULT = null;
		RESULT = trees.noTrees;
              return new jaco.framework.parser.Symbol(70/*RequiresAsopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // SimpleRequiresopt ::= REQUIRES SimpleInterfaceTypeList 
            {
		Tree[] RESULT = null;
		TreeList i = (TreeList)$stack[jcup$top].value;
		 RESULT = i.toArray();
              return jcup$stack.reuse(75/*SimpleRequiresopt*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // SimpleRequiresopt ::= 
            {
		Tree[] RESULT = null;
		RESULT = trees.noTrees;
              return new jaco.framework.parser.Symbol(75/*SimpleRequiresopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // SimpleInterfaceTypeList ::= SimpleInterfaceTypeList COMMA SimpleQualifiedName 
            {
		TreeList RESULT = null;
		TreeList is = (TreeList)$stack[jcup$top-2].value;
		Tree i = (Tree)$stack[jcup$top].value;
		
            RESULT = is.append(i);
              return jcup$stack.reuse(52/*SimpleInterfaceTypeList*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // SimpleInterfaceTypeList ::= SimpleQualifiedName 
            {
		TreeList RESULT = null;
		Tree i = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(i);
              return jcup$stack.reuse(52/*SimpleInterfaceTypeList*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // InterfaceTypeList ::= InterfaceTypeList COMMA ClassOrInterfaceType 
            {
		TreeList RESULT = null;
		TreeList is = (TreeList)$stack[jcup$top-2].value;
		Tree i = (Tree)$stack[jcup$top].value;
		
            RESULT = is.append(i);
              return jcup$stack.reuse(22/*InterfaceTypeList*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // InterfaceTypeList ::= ClassOrInterfaceType 
            {
		TreeList RESULT = null;
		Tree i = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(i);
              return jcup$stack.reuse(22/*InterfaceTypeList*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // SimpleInterfacesopt ::= IMPLEMENTS SimpleInterfaceTypeList 
            {
		Tree[] RESULT = null;
		TreeList i = (TreeList)$stack[jcup$top].value;
		 RESULT = i.toArray();
              return jcup$stack.reuse(55/*SimpleInterfacesopt*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // SimpleInterfacesopt ::= 
            {
		Tree[] RESULT = null;
		RESULT = trees.noTrees;
              return new jaco.framework.parser.Symbol(55/*SimpleInterfacesopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // Interfacesopt ::= IMPLEMENTS InterfaceTypeList 
            {
		Tree[] RESULT = null;
		TreeList i = (TreeList)$stack[jcup$top].value;
		 RESULT = i.toArray();
              return jcup$stack.reuse(54/*Interfacesopt*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // Interfacesopt ::= 
            {
		Tree[] RESULT = null;
		RESULT = trees.noTrees;
              return new jaco.framework.parser.Symbol(54/*Interfacesopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // Super ::= EXTENDS ClassOrInterfaceType 
            {
		Tree RESULT = null;
		Tree s = (Tree)$stack[jcup$top].value;
		 RESULT = s;
              return jcup$stack.reuse(101/*Super*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // Superopt ::= Super 
            {
              return jcup$stack.reuse(100/*Superopt*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // Superopt ::= 
            {
		Tree RESULT = null;
		RESULT = null;
              return new jaco.framework.parser.Symbol(100/*Superopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // ModuleInterfaceMemberDeclaration ::= ModuleImportDeclaration 
            {
		TreeList RESULT = null;
		Tree d = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(50/*ModuleInterfaceMemberDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // ModuleInterfaceMemberDeclaration ::= AbstractModuleFieldDeclaration 
            {
		TreeList RESULT = null;
		Tree d = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(50/*ModuleInterfaceMemberDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // ModuleInterfaceMemberDeclaration ::= InterfaceDeclaration 
            {
		TreeList RESULT = null;
		Tree d = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(50/*ModuleInterfaceMemberDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // ModuleInterfaceMemberDeclaration ::= ClassFieldHeader SEMI 
            {
		TreeList RESULT = null;
		XTree.XClassDecl d = (XTree.XClassDecl)$stack[jcup$top-1].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(50/*ModuleInterfaceMemberDeclaration*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // ModuleInterfaceMemberDeclaration ::= AbstractMethodDeclaration 
            {
		TreeList RESULT = null;
		MethodDecl d = (MethodDecl)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(50/*ModuleInterfaceMemberDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // ModuleInterfaceMemberDeclaration ::= ConstantDeclaration 
            {
              return jcup$stack.reuse(50/*ModuleInterfaceMemberDeclaration*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // ModuleInterfaceMemberDeclarations ::= ModuleInterfaceMemberDeclarations ModuleInterfaceMemberDeclaration 
            {
		TreeList RESULT = null;
		TreeList ds = (TreeList)$stack[jcup$top-1].value;
		TreeList d = (TreeList)$stack[jcup$top].value;
		 RESULT = ds.append(d);
              return jcup$stack.reuse(49/*ModuleInterfaceMemberDeclarations*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // ModuleInterfaceMemberDeclarations ::= ModuleInterfaceMemberDeclaration 
            {
              return jcup$stack.reuse(49/*ModuleInterfaceMemberDeclarations*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // ModuleInterfaceMemberDeclarationsopt ::= ModuleInterfaceMemberDeclarations 
            {
		Tree[] RESULT = null;
		TreeList is = (TreeList)$stack[jcup$top].value;
		 RESULT = is.toArray();
              return jcup$stack.reuse(74/*ModuleInterfaceMemberDeclarationsopt*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // ModuleInterfaceMemberDeclarationsopt ::= 
            {
		Tree[] RESULT = null;
		RESULT = trees.noTrees;
              return new jaco.framework.parser.Symbol(74/*ModuleInterfaceMemberDeclarationsopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // ModuleInterfaceBody ::= LBRACE RecoverAtBrace 
            {
		Tree[] RESULT = null;
		Tree err = (Tree)$stack[jcup$top].value;
		 RESULT = new Tree[]{err};
              return jcup$stack.reuse(73/*ModuleInterfaceBody*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // ModuleInterfaceBody ::= LBRACE ModuleInterfaceMemberDeclarationsopt RBRACE 
            {
		Tree[] RESULT = null;
		Tree[] i = (Tree[])$stack[jcup$top-1].value;
		 RESULT = i;
              return jcup$stack.reuse(73/*ModuleInterfaceBody*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // ModuleInterfaceDeclaration ::= Modifiersopt MODULE INTERFACE IDENTIFIER SPECIALIZES SimpleInterfaceTypeList RequiresAsopt ModuleInterfaceBody 
            {
		Tree RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-7].value;
		Object k = (Object)$stack[jcup$top-6].value;
		Name n = (Name)$stack[jcup$top-4].value;
		TreeList e = (TreeList)$stack[jcup$top-2].value;
		Tree[] r = (Tree[])$stack[jcup$top-1].value;
		Tree[] ds = (Tree[])$stack[jcup$top].value;
		int kleft = $stack[jcup$top-6].left;
		
            RESULT = (ClassDecl)make.XClassDecl(n,
                        m.intValue() | XModifierConst.INTERFACE
                                     | XModifierConst.MODULE
                                     | XModifierConst.SPECIALIZES,
                        null, e.toArray(), r, null, ds).at(kleft);
              return jcup$stack.reuse(166/*ModuleInterfaceDeclaration*/, jcup$top - 7, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // ModuleInterfaceDeclaration ::= Modifiersopt MODULE INTERFACE IDENTIFIER REFINES SimpleInterfaceTypeList SimpleRequiresopt ModuleInterfaceBody 
            {
		Tree RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-7].value;
		Object k = (Object)$stack[jcup$top-6].value;
		Name n = (Name)$stack[jcup$top-4].value;
		TreeList e = (TreeList)$stack[jcup$top-2].value;
		Tree[] r = (Tree[])$stack[jcup$top-1].value;
		Tree[] ds = (Tree[])$stack[jcup$top].value;
		int kleft = $stack[jcup$top-6].left;
		
            RESULT = (ClassDecl)make.XClassDecl(n,
                        m.intValue() | XModifierConst.INTERFACE
                                     | XModifierConst.MODULE,
                        null, e.toArray(), r, null, ds).at(kleft);
              return jcup$stack.reuse(166/*ModuleInterfaceDeclaration*/, jcup$top - 7, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // ModuleInterfaceDeclaration ::= Modifiersopt MODULE INTERFACE IDENTIFIER SimpleRequiresopt ModuleInterfaceBody 
            {
		Tree RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-5].value;
		Object k = (Object)$stack[jcup$top-4].value;
		Name n = (Name)$stack[jcup$top-2].value;
		Tree[] r = (Tree[])$stack[jcup$top-1].value;
		Tree[] ds = (Tree[])$stack[jcup$top].value;
		int kleft = $stack[jcup$top-4].left;
		
            RESULT = (ClassDecl)make.XClassDecl(n,
                        m.intValue() | XModifierConst.INTERFACE
                                     | XModifierConst.MODULE,
                        null, new Tree[0], r, null, ds).at(kleft);
              return jcup$stack.reuse(166/*ModuleInterfaceDeclaration*/, jcup$top - 5, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // ModuleImportDeclaration ::= IMPORT Name DOT STAR SEMI 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-4].value;
		Tree t = (Tree)$stack[jcup$top-3].value;
		int kleft = $stack[jcup$top-4].left;
		
            RESULT = make.Import(XTreeConst.IMPORTMODULESTAR, t).at(kleft);
              return jcup$stack.reuse(171/*ModuleImportDeclaration*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // ModuleImportDeclaration ::= IMPORT Name SEMI 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-2].value;
		Tree t = (Tree)$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-2].left;
		
            RESULT = make.Import(XTreeConst.IMPORTMODULE, t).at(kleft);
              return jcup$stack.reuse(171/*ModuleImportDeclaration*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // AbstractModuleFieldDeclaration ::= Modifiersopt MODULE SimpleQualifiedName AS SimpleInterfaceTypeList SEMI 
            {
		Tree RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-5].value;
		Object k = (Object)$stack[jcup$top-4].value;
		Tree t = (Tree)$stack[jcup$top-3].value;
		Object f = (Object)$stack[jcup$top-2].value;
		TreeList s = (TreeList)$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-4].left;
		int fleft = $stack[jcup$top-2].left;
		
            RESULT = make.ModuleFieldDecl(
            	m.intValue() | XModifierConst.ABSTRACT, 
                make.Overrides(t, s.toArray()).at(fleft), null).at(kleft);
              return jcup$stack.reuse(169/*AbstractModuleFieldDeclaration*/, jcup$top - 5, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // AbstractModuleFieldDeclaration ::= Modifiersopt MODULE SimpleQualifiedName SEMI 
            {
		Tree RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-3].value;
		Object k = (Object)$stack[jcup$top-2].value;
		Tree t = (Tree)$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-2].left;
		
            RESULT = make.ModuleFieldDecl(
                m.intValue() | XModifierConst.ABSTRACT, t, null).at(kleft);
              return jcup$stack.reuse(169/*AbstractModuleFieldDeclaration*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // ModuleFieldDeclaration ::= Modifiersopt MODULE SimpleQualifiedName IMPLEMENTS ModuleList SEMI 
            {
		Tree RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-5].value;
		Object k = (Object)$stack[jcup$top-4].value;
		Tree t = (Tree)$stack[jcup$top-3].value;
		TreeList i = (TreeList)$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-4].left;
		
            RESULT = make.ModuleFieldDecl(m.intValue(), t, i.toArray())
                .at(kleft);
              return jcup$stack.reuse(167/*ModuleFieldDeclaration*/, jcup$top - 5, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // ModuleFieldDeclaration ::= Modifiersopt MODULE SimpleQualifiedName AS SimpleInterfaceTypeList SEMI 
            {
		Tree RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-5].value;
		Object k = (Object)$stack[jcup$top-4].value;
		Tree t = (Tree)$stack[jcup$top-3].value;
		Object f = (Object)$stack[jcup$top-2].value;
		TreeList i = (TreeList)$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-4].left;
		int fleft = $stack[jcup$top-2].left;
		
            RESULT = make.ModuleFieldDecl(m.intValue(),
                make.Overrides(t, i.toArray()).at(fleft), null).at(kleft);
              return jcup$stack.reuse(167/*ModuleFieldDeclaration*/, jcup$top - 5, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // ModuleFieldDeclaration ::= Modifiersopt MODULE SimpleQualifiedName SEMI 
            {
		Tree RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-3].value;
		Object k = (Object)$stack[jcup$top-2].value;
		Tree t = (Tree)$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-2].left;
		
            RESULT = make.ModuleFieldDecl(m.intValue(), t, null).at(kleft);
              return jcup$stack.reuse(167/*ModuleFieldDeclaration*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // CaseDeclaration ::= Modifiersopt CASE IDENTIFIER LPAREN FormalParameterListopt RPAREN 
            {
		Tree RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-5].value;
		Object k = (Object)$stack[jcup$top-4].value;
		Name n = (Name)$stack[jcup$top-3].value;
		VarDecl[] p = (VarDecl[])$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-4].left;
		
            RESULT = make.CaseDecl(n, m.intValue(), p, null).at(kleft);
              return jcup$stack.reuse(102/*CaseDeclaration*/, jcup$top - 5, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // CaseDeclaration ::= Modifiersopt CASE IDENTIFIER 
            {
		Tree RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-2].value;
		Object k = (Object)$stack[jcup$top-1].value;
		Name n = (Name)$stack[jcup$top].value;
		int kleft = $stack[jcup$top-1].left;
		
            RESULT = make.CaseDecl(n, m.intValue(), null, null).at(kleft);
              return jcup$stack.reuse(102/*CaseDeclaration*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // AlgebraicCases ::= AlgebraicCases COMMA CaseDeclaration 
            {
		TreeList RESULT = null;
		TreeList cs = (TreeList)$stack[jcup$top-2].value;
		Tree c = (Tree)$stack[jcup$top].value;
		 RESULT = cs.append(c);
              return jcup$stack.reuse(51/*AlgebraicCases*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // AlgebraicCases ::= CaseDeclaration 
            {
		TreeList RESULT = null;
		Tree c = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(c);
              return jcup$stack.reuse(51/*AlgebraicCases*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // AlgebraicDeclaration ::= Modifiersopt CLASS IDENTIFIER Superopt AlgebraicCases SEMI 
            {
		Tree RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-5].value;
		Object k = (Object)$stack[jcup$top-4].value;
		Name n = (Name)$stack[jcup$top-3].value;
		Tree s = (Tree)$stack[jcup$top-2].value;
		TreeList cs = (TreeList)$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-4].left;
		
            RESULT = (ClassDecl)make.XClassDecl(
                n, m.intValue() |
                XModifierConst.ALGEBRAIC |
                XModifierConst.ABSTRACT,
                s, trees.noTrees, null, null, cs.toArray()).at(kleft);
              return jcup$stack.reuse(172/*AlgebraicDeclaration*/, jcup$top - 5, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // ClassFieldDeclaration ::= ClassFieldHeader EQ SUPER ClassBody SEMI 
            {
		Tree RESULT = null;
		XTree.XClassDecl h = (XTree.XClassDecl)$stack[jcup$top-4].value;
		Object s = (Object)$stack[jcup$top-2].value;
		Tree[] b = (Tree[])$stack[jcup$top-1].value;
		int sleft = $stack[jcup$top-2].left;
		
        	h.superimpl = trees.Super().at(sleft);
        	h.members = b;
        	RESULT = h;
              return jcup$stack.reuse(170/*ClassFieldDeclaration*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // ClassFieldDeclaration ::= ClassFieldHeader EQ ClassOrInterfaceType ClassBody SEMI 
            {
		Tree RESULT = null;
		XTree.XClassDecl h = (XTree.XClassDecl)$stack[jcup$top-4].value;
		Tree t = (Tree)$stack[jcup$top-2].value;
		Tree[] b = (Tree[])$stack[jcup$top-1].value;
		
        	h.superimpl = t;
        	h.members = b;
        	RESULT = h;
              return jcup$stack.reuse(170/*ClassFieldDeclaration*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // ClassFieldDeclaration ::= ClassFieldHeader EQ ClassBody 
            {
		Tree RESULT = null;
		XTree.XClassDecl h = (XTree.XClassDecl)$stack[jcup$top-2].value;
		Tree[] b = (Tree[])$stack[jcup$top].value;
		
        	h.members = b;
        	RESULT = h;
              return jcup$stack.reuse(170/*ClassFieldDeclaration*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // ClassFieldDeclaration ::= ClassFieldHeader EQ SUPER SEMI 
            {
		Tree RESULT = null;
		XTree.XClassDecl h = (XTree.XClassDecl)$stack[jcup$top-3].value;
		Object s = (Object)$stack[jcup$top-1].value;
		int sleft = $stack[jcup$top-1].left;
		
        	h.superimpl = trees.Super().at(sleft);
        	RESULT = h;
              return jcup$stack.reuse(170/*ClassFieldDeclaration*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // ClassFieldDeclaration ::= ClassFieldHeader EQ ClassOrInterfaceType SEMI 
            {
		Tree RESULT = null;
		XTree.XClassDecl h = (XTree.XClassDecl)$stack[jcup$top-3].value;
		Tree t = (Tree)$stack[jcup$top-1].value;
		
        	h.superimpl = t;
        	RESULT = h;
              return jcup$stack.reuse(170/*ClassFieldDeclaration*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // ClassFieldDeclaration ::= ClassFieldHeader SEMI 
            {
		Tree RESULT = null;
		XTree.XClassDecl h = (XTree.XClassDecl)$stack[jcup$top-1].value;
		
            h.mods |= ((h.mods & ModifierConst.ABSTRACT) == 0) ?
            			XModifierConst.OPAQUE : 0;
            RESULT = h;
              return jcup$stack.reuse(170/*ClassFieldDeclaration*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // ClassFieldHeader ::= Modifiersopt CLASS IDENTIFIER Super COMMA InterfaceTypeList Interfacesopt 
            {
		XTree.XClassDecl RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-6].value;
		Object k = (Object)$stack[jcup$top-5].value;
		Name n = (Name)$stack[jcup$top-4].value;
		Tree s = (Tree)$stack[jcup$top-3].value;
		TreeList t = (TreeList)$stack[jcup$top-1].value;
		Tree[] i = (Tree[])$stack[jcup$top].value;
		int kleft = $stack[jcup$top-5].left;
		int sleft = $stack[jcup$top-3].left;
		
			RESULT = (XTree.XClassDecl)make.ClassFieldDecl(m.intValue(), n,
            			make.CompoundType(
            				new TreeList(s).append(t).toArray()).at(sleft),
            			i, null,
            			trees.noTrees, null).at(kleft);
              return jcup$stack.reuse(13/*ClassFieldHeader*/, jcup$top - 6, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // ClassFieldHeader ::= Modifiersopt CLASS IDENTIFIER Super Interfacesopt 
            {
		XTree.XClassDecl RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-4].value;
		Object k = (Object)$stack[jcup$top-3].value;
		Name n = (Name)$stack[jcup$top-2].value;
		Tree s = (Tree)$stack[jcup$top-1].value;
		Tree[] i = (Tree[])$stack[jcup$top].value;
		int kleft = $stack[jcup$top-3].left;
		
			RESULT = (XTree.XClassDecl)make.ClassFieldDecl(m.intValue(), n,
            			s, i, null,
            			trees.noTrees, null).at(kleft);
              return jcup$stack.reuse(13/*ClassFieldHeader*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // ClassFieldHeader ::= Modifiersopt CLASS IDENTIFIER Interfacesopt 
            {
		XTree.XClassDecl RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-3].value;
		Object k = (Object)$stack[jcup$top-2].value;
		Name n = (Name)$stack[jcup$top-1].value;
		Tree[] i = (Tree[])$stack[jcup$top].value;
		int kleft = $stack[jcup$top-2].left;
		
			RESULT = (XTree.XClassDecl)make.ClassFieldDecl(m.intValue(), n,
            			null, i, null,
            			trees.noTrees, null).at(kleft);
              return jcup$stack.reuse(13/*ClassFieldHeader*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // ModuleBodyDeclaration ::= ClassMemberDeclaration 
            {
              return jcup$stack.reuse(47/*ModuleBodyDeclaration*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // ModuleBodyDeclaration ::= Block 
            {
		TreeList RESULT = null;
		Tree d = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(47/*ModuleBodyDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // ModuleBodyDeclaration ::= AlgebraicDeclaration 
            {
		TreeList RESULT = null;
		Tree d = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(47/*ModuleBodyDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // ModuleBodyDeclaration ::= ClassFieldDeclaration 
            {
		TreeList RESULT = null;
		Tree d = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(47/*ModuleBodyDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // ModuleBodyDeclaration ::= ModuleImportDeclaration 
            {
		TreeList RESULT = null;
		Tree d = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(47/*ModuleBodyDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // ModuleBodyDeclaration ::= ModuleFieldDeclaration 
            {
		TreeList RESULT = null;
		Tree d = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(47/*ModuleBodyDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // ModuleBodyDeclarations ::= ModuleBodyDeclarations ModuleBodyDeclaration 
            {
		TreeList RESULT = null;
		TreeList ds = (TreeList)$stack[jcup$top-1].value;
		TreeList d = (TreeList)$stack[jcup$top].value;
		
            RESULT = ds.append(d);
              return jcup$stack.reuse(46/*ModuleBodyDeclarations*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // ModuleBodyDeclarations ::= ModuleBodyDeclaration 
            {
              return jcup$stack.reuse(46/*ModuleBodyDeclarations*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // ModuleBodyDeclarationsopt ::= ModuleBodyDeclarations 
            {
		Tree[] RESULT = null;
		TreeList ds = (TreeList)$stack[jcup$top].value;
		 RESULT = ds.toArray();
              return jcup$stack.reuse(72/*ModuleBodyDeclarationsopt*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // ModuleBodyDeclarationsopt ::= 
            {
		Tree[] RESULT = null;
		RESULT = trees.noTrees;
              return new jaco.framework.parser.Symbol(72/*ModuleBodyDeclarationsopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // ModuleBody ::= LBRACE RecoverAtBrace 
            {
		Tree[] RESULT = null;
		Tree err = (Tree)$stack[jcup$top].value;
		 RESULT = new Tree[]{err};
              return jcup$stack.reuse(71/*ModuleBody*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // ModuleBody ::= LBRACE ModuleBodyDeclarationsopt RBRACE 
            {
		Tree[] RESULT = null;
		Tree[] ds = (Tree[])$stack[jcup$top-1].value;
		 RESULT = ds;
              return jcup$stack.reuse(71/*ModuleBody*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // ModuleDeclaration ::= Modifiersopt MODULE IDENTIFIER SPECIALIZES SimpleQualifiedName SimpleInterfacesopt RequiresAsopt ModuleBody 
            {
		Tree RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-7].value;
		Object k = (Object)$stack[jcup$top-6].value;
		Name n = (Name)$stack[jcup$top-5].value;
		Tree s = (Tree)$stack[jcup$top-3].value;
		Tree[] i = (Tree[])$stack[jcup$top-2].value;
		Tree[] r = (Tree[])$stack[jcup$top-1].value;
		Tree[] ds = (Tree[])$stack[jcup$top].value;
		int kleft = $stack[jcup$top-6].left;
		
            RESULT = (ClassDecl)make.XClassDecl(n,
                        m.intValue() | XModifierConst.MODULE |
                        XModifierConst.SPECIALIZES,
                        s, i, r, null, ds).at(kleft);
              return jcup$stack.reuse(165/*ModuleDeclaration*/, jcup$top - 7, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // ModuleDeclaration ::= Modifiersopt MODULE IDENTIFIER REFINES SimpleQualifiedName SimpleInterfacesopt SimpleRequiresopt ModuleBody 
            {
		Tree RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-7].value;
		Object k = (Object)$stack[jcup$top-6].value;
		Name n = (Name)$stack[jcup$top-5].value;
		Tree s = (Tree)$stack[jcup$top-3].value;
		Tree[] i = (Tree[])$stack[jcup$top-2].value;
		Tree[] r = (Tree[])$stack[jcup$top-1].value;
		Tree[] ds = (Tree[])$stack[jcup$top].value;
		int kleft = $stack[jcup$top-6].left;
		
            RESULT = (ClassDecl)make.XClassDecl(n,
                        m.intValue() | XModifierConst.MODULE,
                        s, i, r, null, ds).at(kleft);
              return jcup$stack.reuse(165/*ModuleDeclaration*/, jcup$top - 7, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // ModuleDeclaration ::= Modifiersopt MODULE IDENTIFIER SimpleInterfacesopt SimpleRequiresopt ModuleBody 
            {
		Tree RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-5].value;
		Object k = (Object)$stack[jcup$top-4].value;
		Name n = (Name)$stack[jcup$top-3].value;
		Tree[] i = (Tree[])$stack[jcup$top-2].value;
		Tree[] r = (Tree[])$stack[jcup$top-1].value;
		Tree[] ds = (Tree[])$stack[jcup$top].value;
		int kleft = $stack[jcup$top-4].left;
		
            RESULT = (ClassDecl)make.XClassDecl(n,
                        m.intValue() | XModifierConst.MODULE,
                        null, i, r, null, ds).at(kleft);
              return jcup$stack.reuse(165/*ModuleDeclaration*/, jcup$top - 5, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // ClassDeclaration ::= Modifiersopt CLASS IDENTIFIER Super Interfacesopt ClassBody 
            {
		Tree RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-5].value;
		Object k = (Object)$stack[jcup$top-4].value;
		Name n = (Name)$stack[jcup$top-3].value;
		Tree s = (Tree)$stack[jcup$top-2].value;
		Tree[] i = (Tree[])$stack[jcup$top-1].value;
		Tree[] ds = (Tree[])$stack[jcup$top].value;
		int kleft = $stack[jcup$top-4].left;
		
            RESULT = (ClassDecl)make.XClassDecl(
                        n, m.intValue(), s, i, null, null, ds).at(kleft);
              return jcup$stack.reuse(174/*ClassDeclaration*/, jcup$top - 5, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // ClassDeclaration ::= Modifiersopt CLASS IDENTIFIER Interfacesopt ClassBody 
            {
		Tree RESULT = null;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top-4].value;
		Object k = (Object)$stack[jcup$top-3].value;
		Name n = (Name)$stack[jcup$top-2].value;
		Tree[] i = (Tree[])$stack[jcup$top-1].value;
		Tree[] ds = (Tree[])$stack[jcup$top].value;
		int kleft = $stack[jcup$top-3].left;
		
            RESULT = (ClassDecl)make.XClassDecl(
                        n, m.intValue(), null, i, null, null, ds).at(kleft);
              return jcup$stack.reuse(174/*ClassDeclaration*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // Modifier ::= STRICTFP 
            {
		Modifiers.Wrapper RESULT = null;
		RESULT = trees.Modifiers(ModifierConst.STRICTFP);
              return jcup$stack.reuse(5/*Modifier*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // Modifier ::= VOLATILE 
            {
		Modifiers.Wrapper RESULT = null;
		RESULT = trees.Modifiers(ModifierConst.VOLATILE);
              return jcup$stack.reuse(5/*Modifier*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // Modifier ::= TRANSIENT 
            {
		Modifiers.Wrapper RESULT = null;
		RESULT = trees.Modifiers(ModifierConst.TRANSIENT);
              return jcup$stack.reuse(5/*Modifier*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // Modifier ::= SYNCHRONIZED 
            {
		Modifiers.Wrapper RESULT = null;
		RESULT = trees.Modifiers(ModifierConst.SYNCHRONIZED);
              return jcup$stack.reuse(5/*Modifier*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // Modifier ::= NATIVE 
            {
		Modifiers.Wrapper RESULT = null;
		RESULT = trees.Modifiers(ModifierConst.NATIVE);
              return jcup$stack.reuse(5/*Modifier*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // Modifier ::= FINAL 
            {
		Modifiers.Wrapper RESULT = null;
		RESULT = trees.Modifiers(ModifierConst.FINAL);
              return jcup$stack.reuse(5/*Modifier*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // Modifier ::= ABSTRACT 
            {
		Modifiers.Wrapper RESULT = null;
		RESULT = trees.Modifiers(ModifierConst.ABSTRACT);
              return jcup$stack.reuse(5/*Modifier*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // Modifier ::= STATIC 
            {
		Modifiers.Wrapper RESULT = null;
		RESULT = trees.Modifiers(ModifierConst.STATIC);
              return jcup$stack.reuse(5/*Modifier*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // Modifier ::= PRIVATE 
            {
		Modifiers.Wrapper RESULT = null;
		RESULT = trees.Modifiers(ModifierConst.PRIVATE);
              return jcup$stack.reuse(5/*Modifier*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // Modifier ::= PROTECTED 
            {
		Modifiers.Wrapper RESULT = null;
		RESULT = trees.Modifiers(ModifierConst.PROTECTED);
              return jcup$stack.reuse(5/*Modifier*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // Modifier ::= PUBLIC 
            {
		Modifiers.Wrapper RESULT = null;
		RESULT = trees.Modifiers(ModifierConst.PUBLIC);
              return jcup$stack.reuse(5/*Modifier*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // Modifiers ::= Modifiers Modifier 
            {
		Modifiers.Wrapper RESULT = null;
		Modifiers.Wrapper mods = (Modifiers.Wrapper)$stack[jcup$top-1].value;
		Modifiers.Wrapper m = (Modifiers.Wrapper)$stack[jcup$top].value;
		 RESULT = mods.add(m);
              return jcup$stack.reuse(4/*Modifiers*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // Modifiers ::= Modifier 
            {
              return jcup$stack.reuse(4/*Modifiers*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // Modifiersopt ::= Modifiers 
            {
		Modifiers.Wrapper RESULT = null;
		Modifiers.Wrapper mods = (Modifiers.Wrapper)$stack[jcup$top].value;
		
            if (lexer.deprecatedFlag) {
                lexer.deprecatedFlag = false;
                RESULT = mods.add(ModifierConst.DEPRECATED);
            } else
                    RESULT = mods;
              return jcup$stack.reuse(3/*Modifiersopt*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // Modifiersopt ::= 
            {
		Modifiers.Wrapper RESULT = null;
		if (lexer.deprecatedFlag) {
                lexer.deprecatedFlag = false;
                RESULT = trees.Modifiers(ModifierConst.DEPRECATED);
            } else
                RESULT = trees.Modifiers(0);
              return new jaco.framework.parser.Symbol(3/*Modifiersopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // TypeDeclaration ::= RecoverAtBrace 
            {
              return jcup$stack.reuse(99/*TypeDeclaration*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // TypeDeclaration ::= SEMI 
            {
		Tree RESULT = null;
		RESULT = null;
              return jcup$stack.reuse(99/*TypeDeclaration*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // TypeDeclaration ::= ModuleInterfaceDeclaration 
            {
              return jcup$stack.reuse(99/*TypeDeclaration*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // TypeDeclaration ::= ModuleDeclaration 
            {
              return jcup$stack.reuse(99/*TypeDeclaration*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // TypeDeclaration ::= InterfaceDeclaration 
            {
              return jcup$stack.reuse(99/*TypeDeclaration*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // TypeDeclaration ::= ClassDeclaration 
            {
              return jcup$stack.reuse(99/*TypeDeclaration*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // TypeImportOnDemandDeclaration ::= IMPORT Name DOT STAR SEMI 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-4].value;
		Tree n = (Tree)$stack[jcup$top-3].value;
		int kleft = $stack[jcup$top-4].left;
		
            RESULT = make.Import(TreeConst.IMPORTSTAR, n).at(kleft);
              return jcup$stack.reuse(98/*TypeImportOnDemandDeclaration*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // SingleTypeImportDeclaration ::= IMPORT Name SEMI 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-2].value;
		Tree n = (Tree)$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-2].left;
		
            RESULT = make.Import(TreeConst.IMPORT, n).at(kleft);
              return jcup$stack.reuse(97/*SingleTypeImportDeclaration*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // ImportDeclaration ::= TypeImportOnDemandDeclaration 
            {
              return jcup$stack.reuse(96/*ImportDeclaration*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // ImportDeclaration ::= SingleTypeImportDeclaration 
            {
              return jcup$stack.reuse(96/*ImportDeclaration*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // PackageDeclaration ::= PACKAGE Name SEMI 
            {
		Tree RESULT = null;
		Object k = (Object)$stack[jcup$top-2].value;
		Tree n = (Tree)$stack[jcup$top-1].value;
		int kleft = $stack[jcup$top-2].left;
		
            RESULT = make.PackageDecl(n).at(kleft);
              return jcup$stack.reuse(95/*PackageDeclaration*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // PackageDeclarationopt ::= PackageDeclaration 
            {
              return jcup$stack.reuse(94/*PackageDeclarationopt*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // PackageDeclarationopt ::= 
            {
		Tree RESULT = null;
		RESULT = null;
              return new jaco.framework.parser.Symbol(94/*PackageDeclarationopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // TypeDeclarations ::= TypeDeclaration TypeDeclarations 
            {
		TreeList RESULT = null;
		Tree d = (Tree)$stack[jcup$top-1].value;
		TreeList ds = (TreeList)$stack[jcup$top].value;
		
            RESULT = ds.prepend(d);
              return jcup$stack.reuse(21/*TypeDeclarations*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // TypeDeclarations ::= TypeDeclaration 
            {
		TreeList RESULT = null;
		Tree d = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(d);
              return jcup$stack.reuse(21/*TypeDeclarations*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // TypeDeclarationsopt ::= TypeDeclarations 
            {
              return jcup$stack.reuse(19/*TypeDeclarationsopt*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // TypeDeclarationsopt ::= 
            {
		TreeList RESULT = null;
		RESULT = trees.TreeList();
              return new jaco.framework.parser.Symbol(19/*TypeDeclarationsopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // ImportDeclarations ::= ImportDeclaration ImportDeclarations 
            {
		TreeList RESULT = null;
		Tree i = (Tree)$stack[jcup$top-1].value;
		TreeList d = (TreeList)$stack[jcup$top].value;
		
            RESULT = d.prepend(i);
              return jcup$stack.reuse(20/*ImportDeclarations*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // ImportDeclarations ::= ImportDeclaration 
            {
		TreeList RESULT = null;
		Tree i = (Tree)$stack[jcup$top].value;
		 RESULT = trees.TreeList(i);
              return jcup$stack.reuse(20/*ImportDeclarations*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // ImportDeclarationsopt ::= ImportDeclarations 
            {
              return jcup$stack.reuse(18/*ImportDeclarationsopt*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // ImportDeclarationsopt ::= 
            {
		TreeList RESULT = null;
		RESULT = null;
              return new jaco.framework.parser.Symbol(18/*ImportDeclarationsopt*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // TopLevel ::= PackageDeclarationopt ImportDeclarationsopt TypeDeclarationsopt 
            {
		CompilationUnit RESULT = null;
		Tree p = (Tree)$stack[jcup$top-2].value;
		TreeList i = (TreeList)$stack[jcup$top-1].value;
		TreeList t = (TreeList)$stack[jcup$top].value;
		int pleft = $stack[jcup$top-2].left;
		
            RESULT = (CompilationUnit)make.CompilationUnit(
                        trees.TreeList(p).append(i).append(t).toArray(),
                        report.getCurrentEnv()).
                     at(pleft);
              return jcup$stack.reuse(2/*TopLevel*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // QualifiedName ::= Name COLONCOLON IDENTIFIER 
            {
		Tree RESULT = null;
		Tree n = (Tree)$stack[jcup$top-2].value;
		Object k = (Object)$stack[jcup$top-1].value;
		Name i = (Name)$stack[jcup$top].value;
		int kleft = $stack[jcup$top-1].left;
		
            RESULT = make.ModuleSelect(n, i).at(kleft);
              return jcup$stack.reuse(93/*QualifiedName*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // QualifiedName ::= Name DOT CLASS 
            {
		Tree RESULT = null;
		Tree n = (Tree)$stack[jcup$top-2].value;
		Object k = (Object)$stack[jcup$top-1].value;
		Object c = (Object)$stack[jcup$top].value;
		int kleft = $stack[jcup$top-1].left;
		
            RESULT = make.Select(n, lexer.tokenName[XSymbols.CLASS]).
                                                at(kleft);
              return jcup$stack.reuse(93/*QualifiedName*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // QualifiedName ::= Name DOT IDENTIFIER 
            {
		Tree RESULT = null;
		Tree n = (Tree)$stack[jcup$top-2].value;
		Object k = (Object)$stack[jcup$top-1].value;
		Name i = (Name)$stack[jcup$top].value;
		int kleft = $stack[jcup$top-1].left;
		
            RESULT = make.Select(n, i).at(kleft);
              return jcup$stack.reuse(93/*QualifiedName*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // SimpleName ::= CONST 
            {
		Name RESULT = null;
		Object c = (Object)$stack[jcup$top].value;
		 RESULT = lexer.tokenName[XSymbols.CONST];
              return jcup$stack.reuse(80/*SimpleName*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // SimpleName ::= GOTO 
            {
		Name RESULT = null;
		Object g = (Object)$stack[jcup$top].value;
		 RESULT = lexer.tokenName[XSymbols.GOTO];
              return jcup$stack.reuse(80/*SimpleName*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // SimpleName ::= IDENTIFIER 
            {
              return jcup$stack.reuse(80/*SimpleName*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // Name ::= QualifiedName 
            {
              return jcup$stack.reuse(92/*Name*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // Name ::= SimpleName 
            {
		Tree RESULT = null;
		Name t = (Name)$stack[jcup$top].value;
		int tleft = $stack[jcup$top].left;
		 RESULT = make.Ident(t).at(tleft);
              return jcup$stack.reuse(92/*Name*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // SimpleQualifiedName ::= SimpleQualifiedName DOT IDENTIFIER 
            {
		Tree RESULT = null;
		Tree n = (Tree)$stack[jcup$top-2].value;
		Object k = (Object)$stack[jcup$top-1].value;
		Name i = (Name)$stack[jcup$top].value;
		int kleft = $stack[jcup$top-1].left;
		
            RESULT = make.Select(n, i).at(kleft);
              return jcup$stack.reuse(90/*SimpleQualifiedName*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // SimpleQualifiedName ::= IDENTIFIER 
            {
		Tree RESULT = null;
		Name t = (Name)$stack[jcup$top].value;
		int tleft = $stack[jcup$top].left;
		 RESULT = make.Ident(t).at(tleft);
              return jcup$stack.reuse(90/*SimpleQualifiedName*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // CompoundType ::= LBRACKET InterfaceTypeList RBRACKET 
            {
		Tree RESULT = null;
		Object b = (Object)$stack[jcup$top-2].value;
		TreeList list = (TreeList)$stack[jcup$top-1].value;
		int bleft = $stack[jcup$top-2].left;
		
            RESULT = make.CompoundType(list.toArray()).at(bleft);
              return jcup$stack.reuse(173/*CompoundType*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // ArrayType ::= Name Dims 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top-1].value;
		ArrayTypeTerm d = (ArrayTypeTerm)$stack[jcup$top].value;
		
            replaceArrayType(d, e);
            RESULT = d;
              return jcup$stack.reuse(91/*ArrayType*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // ArrayType ::= PrimitiveType Dims 
            {
		Tree RESULT = null;
		Tree e = (Tree)$stack[jcup$top-1].value;
		ArrayTypeTerm d = (ArrayTypeTerm)$stack[jcup$top].value;
		
            replaceArrayType(d, e);
            RESULT = d;
              return jcup$stack.reuse(91/*ArrayType*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // ClassOrInterfaceType ::= Name 
            {
              return jcup$stack.reuse(89/*ClassOrInterfaceType*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // ReferenceType ::= CompoundType 
            {
              return jcup$stack.reuse(88/*ReferenceType*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // ReferenceType ::= ArrayType 
            {
              return jcup$stack.reuse(88/*ReferenceType*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // ReferenceType ::= ClassOrInterfaceType 
            {
              return jcup$stack.reuse(88/*ReferenceType*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // FloatingPointType ::= DOUBLE 
            {
		Tree RESULT = null;
		Object t = (Object)$stack[jcup$top].value;
		int tleft = $stack[jcup$top].left;
		 RESULT = make.BasicType(TypeConst.DOUBLE).at(tleft);
              return jcup$stack.reuse(87/*FloatingPointType*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // FloatingPointType ::= FLOAT 
            {
		Tree RESULT = null;
		Object t = (Object)$stack[jcup$top].value;
		int tleft = $stack[jcup$top].left;
		 RESULT = make.BasicType(TypeConst.FLOAT).at(tleft);
              return jcup$stack.reuse(87/*FloatingPointType*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // IntegralType ::= CHAR 
            {
		Tree RESULT = null;
		Object t = (Object)$stack[jcup$top].value;
		int tleft = $stack[jcup$top].left;
		 RESULT = make.BasicType(TypeConst.CHAR).at(tleft);
              return jcup$stack.reuse(86/*IntegralType*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // IntegralType ::= LONG 
            {
		Tree RESULT = null;
		Object t = (Object)$stack[jcup$top].value;
		int tleft = $stack[jcup$top].left;
		 RESULT = make.BasicType(TypeConst.LONG).at(tleft);
              return jcup$stack.reuse(86/*IntegralType*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // IntegralType ::= INT 
            {
		Tree RESULT = null;
		Object t = (Object)$stack[jcup$top].value;
		int tleft = $stack[jcup$top].left;
		 RESULT = make.BasicType(TypeConst.INT).at(tleft);
              return jcup$stack.reuse(86/*IntegralType*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // IntegralType ::= SHORT 
            {
		Tree RESULT = null;
		Object t = (Object)$stack[jcup$top].value;
		int tleft = $stack[jcup$top].left;
		 RESULT = make.BasicType(TypeConst.SHORT).at(tleft);
              return jcup$stack.reuse(86/*IntegralType*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // IntegralType ::= BYTE 
            {
		Tree RESULT = null;
		Object t = (Object)$stack[jcup$top].value;
		int tleft = $stack[jcup$top].left;
		 RESULT = make.BasicType(TypeConst.BYTE).at(tleft);
              return jcup$stack.reuse(86/*IntegralType*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // NumericType ::= FloatingPointType 
            {
              return jcup$stack.reuse(85/*NumericType*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // NumericType ::= IntegralType 
            {
              return jcup$stack.reuse(85/*NumericType*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // PrimitiveType ::= BOOLEAN 
            {
		Tree RESULT = null;
		Object t = (Object)$stack[jcup$top].value;
		int tleft = $stack[jcup$top].left;
		 RESULT = make.BasicType(TypeConst.
                                                BOOLEAN).at(tleft);
              return jcup$stack.reuse(84/*PrimitiveType*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // PrimitiveType ::= NumericType 
            {
              return jcup$stack.reuse(84/*PrimitiveType*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // Type ::= ReferenceType 
            {
              return jcup$stack.reuse(83/*Type*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // Type ::= PrimitiveType 
            {
              return jcup$stack.reuse(83/*Type*/);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // Literal ::= STRINGLITERAL 
            {
		Tree RESULT = null;
		Constant c = (Constant)$stack[jcup$top].value;
		int cleft = $stack[jcup$top].left;
		 RESULT = make.Literal(c).at(cleft);
              return jcup$stack.reuse(82/*Literal*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // Literal ::= CHARLITERAL 
            {
		Tree RESULT = null;
		Constant c = (Constant)$stack[jcup$top].value;
		int cleft = $stack[jcup$top].left;
		 RESULT = make.Literal(c).at(cleft);
              return jcup$stack.reuse(82/*Literal*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // Literal ::= DOUBLELITERAL 
            {
		Tree RESULT = null;
		Constant c = (Constant)$stack[jcup$top].value;
		int cleft = $stack[jcup$top].left;
		 RESULT = make.Literal(c).at(cleft);
              return jcup$stack.reuse(82/*Literal*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // Literal ::= FLOATLITERAL 
            {
		Tree RESULT = null;
		Constant c = (Constant)$stack[jcup$top].value;
		int cleft = $stack[jcup$top].left;
		 RESULT = make.Literal(c).at(cleft);
              return jcup$stack.reuse(82/*Literal*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // Literal ::= LONGLITERAL 
            {
		Tree RESULT = null;
		Constant c = (Constant)$stack[jcup$top].value;
		int cleft = $stack[jcup$top].left;
		 RESULT = make.Literal(c).at(cleft);
              return jcup$stack.reuse(82/*Literal*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // Literal ::= INTLITERAL 
            {
		Tree RESULT = null;
		Constant c = (Constant)$stack[jcup$top].value;
		int cleft = $stack[jcup$top].left;
		 RESULT = make.Literal(c).at(cleft);
              return jcup$stack.reuse(82/*Literal*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // Goal ::= TopLevel 
            {
		CompilationUnit RESULT = null;
		CompilationUnit c = (CompilationUnit)$stack[jcup$top].value;
		 RESULT = c;
              return jcup$stack.reuse(1/*Goal*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= Goal EOF 
            {
      jaco.framework.parser.Symbol jcup$result;
		Object RESULT = null;
		CompilationUnit start_val = (CompilationUnit)$stack[jcup$top-1].value;
		RESULT = start_val;
              jcup$result = new jaco.framework.parser.Symbol(0/*$START*/, jcup$top - 1, jcup$top, RESULT);
          /* ACCEPT */
          jcup$parser.done_parsing();
          return jcup$result;
            }

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
};

