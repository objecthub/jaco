//----------------------------------------------------
// code was generated by JCUP V0.12
// Fri Feb 12 12:15:54 GMT+10:30 1999
//----------------------------------------------------

package jcup;

import jcup.runtime.*;
import java.util.Hashtable;

public final class parser extends LRParser {

  /** constructor */
  public parser() {super();}

  /** production table */
  protected static final short _production_table[][] = {
        {0, 2},     {39, 0},     {1, 10},     {1, 5},     {40, 0}, 
        {2, 4},     {2, 1},     {3, 2},     {3, 1},     {41, 0}, 
        {11, 4},     {4, 2},     {5, 4},     {5, 1},     {6, 4}, 
        {6, 1},     {13, 4},     {13, 1},     {14, 4},     {14, 1}, 
        {7, 2},     {7, 1},     {15, 3},     {15, 2},     {15, 4}, 
        {15, 3},     {42, 0},     {15, 4},     {43, 0},     {15, 5}, 
        {44, 0},     {31, 3},     {45, 0},     {32, 3},     {17, 3}, 
        {17, 1},     {18, 3},     {18, 1},     {27, 1},     {27, 1}, 
        {30, 2},     {30, 1},     {46, 0},     {28, 5},     {47, 0}, 
        {28, 5},     {48, 0},     {28, 5},     {29, 3},     {29, 1}, 
        {37, 1},     {38, 1},     {49, 0},     {8, 5},     {8, 1}, 
        {9, 2},     {9, 1},     {50, 0},     {51, 0},     {19, 6}, 
        {52, 0},     {19, 3},     {24, 3},     {24, 1},     {25, 3}, 
        {25, 1},     {20, 2},     {20, 1},     {21, 2},     {21, 1}, 
        {36, 2},     {36, 1},     {10, 3},     {10, 1},     {12, 3}, 
        {12, 1},     {16, 1},     {16, 3},     {22, 1},     {23, 1}, 
        {33, 1},     {34, 1},     {35, 1},     {26, 0}  };

  /** access to production table */
  public short[][] production_table() {return _production_table;}

  /** parse action table */
  protected static short[][] _action_table;

  /** access to parse action table */
  public short[][] action_table() {return _action_table;}

  /** reduce_goto table */
  protected static short[][] _reduce_table;

  /** access to reduce_goto table */
  public short[][] reduce_table() {return _reduce_table;}

  static {
    try {
      java.io.ObjectInputStream p = new java.io.ObjectInputStream(find_tables("jcup.parser"));
      _action_table = (short[][])p.readObject();
      _reduce_table = (short[][])p.readObject();
    }
    catch (Exception e) {
      throw new RuntimeException("unable to load parser tables: " + e);
    }
  }
  /** instance of action encapsulation class */
  protected parserActions action_obj;

  /** action encapsulation object initializer */
  protected void init_actions()
  {
      actObj = (action_obj = new parserActions(this, stack));
  }

  /** start state */
  public final int start_state() {return 0;}
  /** start production */
  public final int start_production() { return 0; }

  /** EOF Symbol index */
  public final int EOF_sym() { return 0; }

  /** error Symbol index */
  public final int error_sym() { return 1; }


  /** user initialization */
  public final void user_init() throws java.lang.Exception
  {
 lexer.init(); 
  }

  /** scan to get the next Symbol */
  public final jcup.runtime.Symbol scan()
    throws java.lang.Exception
  {
 return lexer.next_token(); 
  }



  /* override error routines */

  public void report_fatal_error(
    String   message,
    Object   info)
    {
      done_parsing();
      lexer.emit_error(message);
      System.err.println("Can't recover from previous error(s), giving up.");
      System.exit(1);
    }

    public void report_error(String message, Object info)
    {
      lexer.emit_error(message);
    }

};

/** Cup generated class to encapsulate user supplied action code.*/
class parserActions implements ActionInterface{
  protected jcup.runtime.LRParser   jcup$parser;
  protected jcup.runtime.ParseStack jcup$stack;


  /** helper routine to clone a new production part adding a given label */
  protected production_part add_lab(production_part part, String lab)
    throws internal_error
    {
      /* if there is no label, or this is an action, just return the original */
      if (lab == null || part.is_action()) return part;

      /* otherwise build a new one with the given label attached */
      return new symbol_part(((symbol_part)part).the_symbol(),lab);
    }

  /** max size of right hand side we will support */
  protected final int MAX_RHS = 200;

  /** array for accumulating right hand side parts */
  protected production_part[] rhs_parts = new production_part[MAX_RHS];

  /** where we are currently in building a right hand side */
  protected int rhs_pos = 0;

  /** start a new right hand side */
  protected void new_rhs() {rhs_pos = 0; }

  /** add a new right hand side part */
  protected void add_rhs_part(production_part part) throws java.lang.Exception
    {
      if (rhs_pos >= MAX_RHS)
    throw new Exception("Internal Error: Productions limited to " + 
                 MAX_RHS + " symbols and actions"); 

      rhs_parts[rhs_pos] = part;
      rhs_pos++;
    }

  /** string to build up multiple part names */
  protected String multipart_name = new String();

  /** append a new name segment to the accumulated multipart name */
  protected void append_multipart(String name)
    {
      String dot = "";

      /* if we aren't just starting out, put on a dot */
      if (multipart_name.length() != 0)  dot = ".";

      multipart_name = multipart_name.concat(dot + name);
    }

  /** table of declared symbols -- contains production parts indexed by name */
  protected Hashtable symbols = new Hashtable();

  /** table of just non terminals -- contains non_terminals indexed by name */
  protected Hashtable non_terms = new Hashtable();

  /** declared start non_terminal */
  protected non_terminal start_nt = null;

  /** left hand side non terminal of the current production */
  protected non_terminal lhs_nt;

  /** Current precedence number */
  int _cur_prec = 0;

  /** Current precedence side */
  int _cur_side = assoc.no_prec;

  /** update the precedences we are declaring */
  protected void update_precedence(int p) {
    _cur_side = p;
    _cur_prec++;
  }
  /** add relevant data to terminals */ 
  protected void add_precedence(String term) {
    if (term == null) {
      System.err.println("Unable to add precedence to nonexistent terminal");
    } else {
      symbol_part sp = (symbol_part)symbols.get(term);
      if (sp == null) {
    System.err.println("Could find terminal " + term + " while declaring precedence");
      } else {
    jcup.symbol sym = sp.the_symbol();
    if (sym instanceof terminal) 
      ((terminal)sym).set_precedence(_cur_side, _cur_prec);
    else System.err.println("Precedence declaration: Can't find terminal " + term);
      }
    }
  }


  /** Constructor */
  parserActions(
    jcup.runtime.LRParser   parser,
    jcup.runtime.ParseStack stack)
  {
      jcup$parser = parser;
      jcup$stack = stack;
  }

  /** Method with the actual generated action code. */
  public final jcup.runtime.Symbol doAction(
    int jcup$act_num,
    int jcup$top)
    throws java.lang.Exception
    {
      /* the parse stack */
      jcup.runtime.Symbol[] $stack = jcup$stack.stack;

      /* select the action based on the action number */
      switch (jcup$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // empty ::= 
            {
        Object RESULT = null;
        
              return new jcup.runtime.Symbol(26/*empty*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // label_id ::= ID 
            {
        String RESULT = null;
        String the_id = (String)$stack[jcup$top].value;
         RESULT = the_id;
              return jcup$stack.reuse(35/*label_id*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // symbol_id ::= ID 
            {
        String RESULT = null;
        String the_id = (String)$stack[jcup$top].value;
         RESULT = the_id;
              return jcup$stack.reuse(34/*symbol_id*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // nt_id ::= ID 
            {
        String RESULT = null;
        String the_id = (String)$stack[jcup$top].value;
         RESULT = the_id;
              return jcup$stack.reuse(33/*nt_id*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // new_non_term_id ::= ID 
            {
        Object RESULT = null;
        String non_term_id = (String)$stack[jcup$top].value;
         
      /* see if this non terminal has been declared before */
      if (symbols.get(non_term_id) != null)
        {
          /* issue a message */
          lexer.emit_error( "jcup.runtime.Symbol \"" + non_term_id + 
                                  "\" has already been declared");
        }
      else
        {
          if (multipart_name.equals("")) {
        append_multipart("Object");
          }
          /* build the non terminal object */
              non_terminal this_nt = 
        new non_terminal(non_term_id, multipart_name);

          /* put it in the non_terms table */
          non_terms.put(non_term_id, this_nt);

          /* build a production_part and put it in the symbols table */ 
          symbols.put(non_term_id, new symbol_part(this_nt));
        }
              return jcup$stack.reuse(23/*new_non_term_id*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // new_term_id ::= ID 
            {
        Object RESULT = null;
        String term_id = (String)$stack[jcup$top].value;
         
      /* see if this terminal has been declared before */
      if (symbols.get(term_id) != null)
        {
          /* issue a message */
          lexer.emit_error("jcup.runtime.Symbol \"" + term_id + 
               "\" has already been declared");
        }
      else
        {
          /* if no type declared, declare one */
          if (multipart_name.equals("")) {
        append_multipart("Object");
          }
          /* build a production_part and put it in the table */ 
          symbols.put(term_id, 
            new symbol_part(new terminal(term_id, multipart_name)));
        }
              return jcup$stack.reuse(22/*new_term_id*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // type_id ::= type_id LBRACK RBRACK 
            {
        Object RESULT = null;
        multipart_name = multipart_name.concat("[]");
              return jcup$stack.reuse(16/*type_id*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // type_id ::= multipart_id 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(16/*type_id*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // import_id ::= multipart_id 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(12/*import_id*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // import_id ::= multipart_id DOT STAR 
            {
        Object RESULT = null;
        append_multipart("*");
              return jcup$stack.reuse(12/*import_id*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // multipart_id ::= ID 
            {
        Object RESULT = null;
        String an_id = (String)$stack[jcup$top].value;
         append_multipart(an_id);
              return jcup$stack.reuse(10/*multipart_id*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // multipart_id ::= multipart_id DOT ID 
            {
        Object RESULT = null;
        String another_id = (String)$stack[jcup$top].value;
         append_multipart(another_id);
              return jcup$stack.reuse(10/*multipart_id*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // opt_label ::= empty 
            {
        String RESULT = null;
        RESULT = null;
              return jcup$stack.reuse(36/*opt_label*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // opt_label ::= COLON label_id 
            {
        String RESULT = null;
        String labid = (String)$stack[jcup$top].value;
         RESULT = labid;
              return jcup$stack.reuse(36/*opt_label*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // prod_part ::= CODE_STRING 
            {
        Object RESULT = null;
        String code_str = (String)$stack[jcup$top].value;
         
      /* add a new production part */
      add_rhs_part(new action_part(code_str));
              return jcup$stack.reuse(21/*prod_part*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // prod_part ::= symbol_id opt_label 
            {
        Object RESULT = null;
        String symid = (String)$stack[jcup$top-1].value;
        String labid = (String)$stack[jcup$top].value;
         
      /* try to look up the id */
      production_part symb = (production_part)symbols.get(symid);

      /* if that fails, symbol is undeclared */
      if (symb == null)
        {
          if (lexer.error_count == 0)
            lexer.emit_error("jcup.runtime.Symbol \"" + symid + 
                   "\" has not been declared");
        }
      else
        {
          /* add a labeled production part */
          add_rhs_part(add_lab(symb, labid));
        }
              return jcup$stack.reuse(21/*prod_part*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // prod_part_list ::= empty 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(20/*prod_part_list*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // prod_part_list ::= prod_part_list prod_part 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(20/*prod_part_list*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // rhs ::= prod_part_list 
            {
        Object RESULT = null;
        if (lhs_nt != null) 
        {
          /* build the production */
          production p = new production(lhs_nt, rhs_parts, rhs_pos);

          /* if we have no start non-terminal declared and this is 
         the first production, make its lhs nt the start_nt 
         and build a special start production for it. */
              if (start_nt == null)
        {
          start_nt = lhs_nt;

              /* build a special start production */
              new_rhs();
              add_rhs_part(add_lab(new symbol_part(start_nt),"start_val"));
              add_rhs_part(new symbol_part(terminal.EOF));
          add_rhs_part(new action_part("RESULT = start_val;"));
              emit.start_production = 
             new production(non_terminal.START_nt, rhs_parts, rhs_pos);

              new_rhs();
        }
        }
      
      /* reset the rhs accumulation in any case */
      new_rhs();
              return jcup$stack.reuse(25/*rhs*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // rhs ::= prod_part_list PERCENT_PREC term_id 
            {
        Object RESULT = null;
        String term_name = (String)$stack[jcup$top].value;
        
      jcup.symbol sym = null;
      if (lhs_nt != null) 
        {
          /* Find the precedence symbol */
          if (term_name == null) {
        System.err.println("No terminal for contextual precedence");
        sym = null;
          } else {
        sym = ((symbol_part)symbols.get(term_name)).the_symbol();
          }
          /* build the production */
          production p;
          if ((sym!=null) && (sym instanceof terminal)) {
        p = new production(lhs_nt, rhs_parts, rhs_pos,
                   ((terminal)sym).precedence_num(),
                   ((terminal)sym).precedence_side());
        ((symbol_part)symbols.get(term_name)).the_symbol().note_use();
          } else {
        System.err.println("Invalid terminal " + term_name + 
                   " for contextual precedence assignment");
        p = new production(lhs_nt, rhs_parts, rhs_pos);
          }

          /* if we have no start non-terminal declared and this is 
         the first production, make its lhs nt the start_nt 
         and build a special start production for it. */
              if (start_nt == null)
        {
          start_nt = lhs_nt;

              /* build a special start production */
              new_rhs();
              add_rhs_part(add_lab(new symbol_part(start_nt),"start_val"));
              add_rhs_part(new symbol_part(terminal.EOF));
          add_rhs_part(new action_part("RESULT = start_val;"));
          if ((sym!=null) && (sym instanceof terminal)) {
            emit.start_production = 
              new production(non_terminal.START_nt, rhs_parts, 
                     rhs_pos, ((terminal)sym).precedence_num(),
                     ((terminal)sym).precedence_side());
          } else {
            emit.start_production = 
              new production(non_terminal.START_nt, rhs_parts, rhs_pos);
          }
              new_rhs();
        }
        }

      /* reset the rhs accumulation in any case */
      new_rhs();
              return jcup$stack.reuse(25/*rhs*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // rhs_list ::= rhs 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(24/*rhs_list*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // rhs_list ::= rhs_list BAR rhs 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(24/*rhs_list*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // production ::= error NT$13 SEMI 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(19/*production*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // NT$13 ::= 
            {
        Object RESULT = null;
        lexer.emit_error("Syntax Error");
              return new jcup.runtime.Symbol(52/*NT$13*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // production ::= nt_id NT$11 COLON_COLON_EQUALS NT$12 rhs_list SEMI 
            {
        Object RESULT = null;
        String lhs_id = (String)$stack[jcup$top-5].value;
              return jcup$stack.reuse(19/*production*/, jcup$top - 5, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // NT$12 ::= 
            {
        Object RESULT = null;
        String lhs_id = (String)$stack[jcup$top-2].value;
              return new jcup.runtime.Symbol(51/*NT$12*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // NT$11 ::= 
            {
        Object RESULT = null;
        String lhs_id = (String)$stack[jcup$top].value;

      /* lookup the lhs nt */
      lhs_nt = (non_terminal)non_terms.get(lhs_id);

          /* if it wasn't declared, emit a message */
      if (lhs_nt == null)
        {
          if (lexer.error_count == 0)
            lexer.emit_error("LHS non terminal \"" + lhs_id + 
                   "\" has not been declared");
        }

      /* reset the rhs accumulation */
      new_rhs();
              return new jcup.runtime.Symbol(50/*NT$11*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // production_list ::= production 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(9/*production_list*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // production_list ::= production_list production 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(9/*production_list*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // start_spec ::= empty 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(8/*start_spec*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // start_spec ::= START WITH nt_id NT$10 SEMI 
            {
        Object RESULT = null;
        String start_name = (String)$stack[jcup$top-2].value;
              return jcup$stack.reuse(8/*start_spec*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // NT$10 ::= 
            {
        Object RESULT = null;
        String start_name = (String)$stack[jcup$top].value;
 
      /* verify that the name has been declared as a non terminal */
      non_terminal nt = (non_terminal)non_terms.get(start_name);
      if (nt == null)
        {
          lexer.emit_error( "Start non terminal \"" + start_name + 
                     "\" has not been declared");
        }
          else
        {
          /* remember the non-terminal for later */
          start_nt = nt;

          /* build a special start production */
          new_rhs();
          add_rhs_part(add_lab(new symbol_part(start_nt), "start_val"));
          add_rhs_part(new symbol_part(terminal.EOF));
          add_rhs_part(new action_part("RESULT = start_val;"));
          emit.start_production = 
             new production(non_terminal.START_nt, rhs_parts, rhs_pos);
          new_rhs();
        }
              return new jcup.runtime.Symbol(49/*NT$10*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // term_id ::= symbol_id 
            {
        String RESULT = null;
        String sym = (String)$stack[jcup$top].value;
        
      /* check that the symbol_id is a terminal */
      if (symbols.get(sym) == null)
        {
          /* issue a message */
          lexer.emit_error("Terminal \"" + sym + 
               "\" has not been declared");
        }
          RESULT = sym;
              return jcup$stack.reuse(38/*term_id*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // terminal_id ::= term_id 
            {
        String RESULT = null;
        String sym = (String)$stack[jcup$top].value;
            
      add_precedence(sym);
      RESULT = sym;
              return jcup$stack.reuse(37/*terminal_id*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // terminal_list ::= terminal_id 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(29/*terminal_list*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // terminal_list ::= terminal_list COMMA terminal_id 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(29/*terminal_list*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // preced ::= PRECEDENCE NONASSOC NT$9 terminal_list SEMI 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(28/*preced*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // NT$9 ::= 
            {
        Object RESULT = null;
        update_precedence(assoc.nonassoc);
              return new jcup.runtime.Symbol(48/*NT$9*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // preced ::= PRECEDENCE RIGHT NT$8 terminal_list SEMI 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(28/*preced*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // NT$8 ::= 
            {
        Object RESULT = null;
        update_precedence(assoc.right);
              return new jcup.runtime.Symbol(47/*NT$8*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // preced ::= PRECEDENCE LEFT NT$7 terminal_list SEMI 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(28/*preced*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // NT$7 ::= 
            {
        Object RESULT = null;
        update_precedence(assoc.left);
              return new jcup.runtime.Symbol(46/*NT$7*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // precedence_l ::= preced 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(30/*precedence_l*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // precedence_l ::= precedence_l preced 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(30/*precedence_l*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // precedence_list ::= empty 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(27/*precedence_list*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // precedence_list ::= precedence_l 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(27/*precedence_list*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // non_term_name_list ::= new_non_term_id 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(18/*non_term_name_list*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // non_term_name_list ::= non_term_name_list COMMA new_non_term_id 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(18/*non_term_name_list*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // term_name_list ::= new_term_id 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(17/*term_name_list*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // term_name_list ::= term_name_list COMMA new_term_id 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(17/*term_name_list*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // declares_non_term ::= non_term_name_list NT$6 SEMI 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(32/*declares_non_term*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // NT$6 ::= 
            {
        Object RESULT = null;
        /* reset the accumulated multipart name */
      multipart_name = new String();
              return new jcup.runtime.Symbol(45/*NT$6*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // declares_term ::= term_name_list NT$5 SEMI 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(31/*declares_term*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // NT$5 ::= 
            {
        Object RESULT = null;
        /* reset the accumulated multipart name */
      multipart_name = new String();
              return new jcup.runtime.Symbol(44/*NT$5*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // symbol ::= NON TERMINAL error NT$4 SEMI 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(15/*symbol*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // NT$4 ::= 
            {
        Object RESULT = null;
        /* reset the accumulated multipart name */
      multipart_name = new String();
              return new jcup.runtime.Symbol(43/*NT$4*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // symbol ::= TERMINAL error NT$3 SEMI 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(15/*symbol*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // NT$3 ::= 
            {
        Object RESULT = null;
        /* reset the accumulated multipart name */
      multipart_name = new String();
              return new jcup.runtime.Symbol(42/*NT$3*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // symbol ::= NON TERMINAL declares_non_term 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(15/*symbol*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // symbol ::= NON TERMINAL type_id declares_non_term 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(15/*symbol*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // symbol ::= TERMINAL declares_term 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(15/*symbol*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // symbol ::= TERMINAL type_id declares_term 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(15/*symbol*/, jcup$top - 2, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // symbol_list ::= symbol 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(7/*symbol_list*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // symbol_list ::= symbol_list symbol 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(7/*symbol_list*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // scan_code ::= empty 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(14/*scan_code*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // scan_code ::= SCAN WITH CODE_STRING SEMI 
            {
        Object RESULT = null;
        String user_code = (String)$stack[jcup$top-1].value;
         
      /* save the user code */
      emit.scan_code = user_code;
              return jcup$stack.reuse(14/*scan_code*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // init_code ::= empty 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(13/*init_code*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // init_code ::= INIT WITH CODE_STRING SEMI 
            {
        Object RESULT = null;
        String user_code = (String)$stack[jcup$top-1].value;
         
      /* save the user code */
      emit.init_code = user_code;
              return jcup$stack.reuse(13/*init_code*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // parser_code_part ::= empty 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(6/*parser_code_part*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // parser_code_part ::= PARSER CODE CODE_STRING SEMI 
            {
        Object RESULT = null;
        String user_code = (String)$stack[jcup$top-1].value;
        
      /* save the user included code string */
      emit.parser_code = user_code;
              return jcup$stack.reuse(6/*parser_code_part*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // action_code_part ::= empty 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(5/*action_code_part*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // action_code_part ::= ACTION CODE CODE_STRING SEMI 
            {
        Object RESULT = null;
        String user_code = (String)$stack[jcup$top-1].value;
        
      /* save the user included code string */
      emit.action_code = user_code;
              return jcup$stack.reuse(5/*action_code_part*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // code_part ::= action_code_part parser_code_part 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(4/*code_part*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // import_spec ::= IMPORT import_id NT$2 SEMI 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(11/*import_spec*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // NT$2 ::= 
            {
        Object RESULT = null;
        /* save this import on the imports list */
      emit.import_list.push(multipart_name);

      /* reset the accumulated multipart name */
      multipart_name = new String();
              return new jcup.runtime.Symbol(41/*NT$2*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // import_list ::= empty 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(3/*import_list*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // import_list ::= import_list import_spec 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(3/*import_list*/, jcup$top - 1, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // package_spec ::= empty 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(2/*package_spec*/, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // package_spec ::= PACKAGE multipart_id NT$1 SEMI 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(2/*package_spec*/, jcup$top - 3, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // NT$1 ::= 
            {
        Object RESULT = null;
        /* save the package name */
      emit.package_name = multipart_name;

      /* reset the accumulated multipart name */
      multipart_name = new String();
              return new jcup.runtime.Symbol(40/*NT$1*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // spec ::= error symbol_list precedence_list start_spec production_list 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(1/*spec*/, jcup$top - 4, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // spec ::= NT$0 package_spec import_list code_part init_code scan_code symbol_list precedence_list start_spec production_list 
            {
        Object RESULT = null;
        
              return jcup$stack.reuse(1/*spec*/, jcup$top - 9, jcup$top, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
        Object RESULT = null;
        /* declare "error" as a terminal */
          symbols.put("error", new symbol_part(terminal.error));

          /* declare start non terminal */
          non_terms.put("$START", non_terminal.START_nt);
              return new jcup.runtime.Symbol(39/*NT$0*/, $stack[jcup$top].left, $stack[jcup$top].left, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= spec EOF 
            {
      jcup.runtime.Symbol jcup$result;
        Object RESULT = null;
        Object start_val = (Object)$stack[jcup$top-1].value;
        RESULT = start_val;
              jcup$result = new jcup.runtime.Symbol(0/*$START*/, jcup$top - 1, jcup$top, RESULT);
          /* ACCEPT */
          jcup$parser.done_parsing();
          return jcup$result;
            }

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
};

